# 基础算法

比较基础而且是比较重要的一些模块，比如二叉树，前序遍历；中序遍历；后序遍历其实结合起来是递归的思维，所以对于掌握这些基础算法的思维是非常有必要的，对于一些有规律的地方适当地背下模版，因为现实打题都是限时的，不可能让你有很多的时间去考虑整个框架的问题。3/12 日的笔试后发现自己有点高估自己的水平了，所以还是踏踏实实地把算法整体的思想和套路过一遍，再去刷刷牛客上一些偏向于实际问题的题目。

## 一、专题之排序

1. 快速排序

```js
const QSort = function (arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const left = [],
    right = [],
    mid = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < mid) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return [...QSort(left), mid, ...QSort(right)];
};
```

```js
// 第二种方法
var QuickSort = function (nums, left, right) {
  if (left > right) {
    return;
  }

  const tmp = nums[left];
  let i = left,
    j = right;

  while (i < j) {
    while (i < j && nums[j] >= tmp) {
      j--;
    }
    nums[i] = nums[j];

    while (i < j && nums[i] <= tmp) {
      i++;
    }
    nums[j] = nums[i];
  }
  nums[j] = tmp;
  QuickSort(nums, left, j - 1);
  QuickSort(nums, j + 1, right);
};
```

2. 归并排序

```js
const merge = function (l1, l2) {
  const l3 = [];
  let i = 0,
    j = 0;
  while (i < l1.length && j < l2.length) {
    if (l1[i] < l2[j]) {
      l3.push(l1[i++]);
    } else {
      l3.push(l2[j++]);
    }
  }
  i !== l1.length && l3.push(...l1.slice(i));
  j !== l2.length && l3.push(...l2.slice(j));
  return l3;
};

const MergeSort = function (arr) {
  if (arr.length <= 1) {
    return arr;
  }

  let mid = Math.floor(arr.length / 2),
    left = arr.slice(0, mid),
    right = arr.slice(mid);
  return merge(MergeSort(left), MergeSort(right));
};
```

3. 堆排序

```js
function HeapSort(arr) {
  let heapSize = arr.length; // 遗漏的点
  let mid = Math.floor(heapSize / 2) - 1;

  for (let i = mid; i >= 0; i--) {
    Heap(arr, i, heapSize); // 建堆过程
  }

  for (let i = heapSize - 1; i >= 1; i--) {
    // 排序调整堆过程
    let t = arr[0];
    arr[0] = arr[i];
    arr[i] = t;
    Heap(arr, 0, --heapSize); // 需要注意的点
  }

  return arr;
}

function Heap(arr, mid, heapSize) {
  let left = 2 * mid + 1,
    right = 2 * mid + 2,
    largest = mid;
  if (left < heapSize && arr[left] > arr[largest]) {
    largest = left;
  }
  if (right < heapSize && arr[right] > arr[largest]) {
    largest = right;
  }

  if (largest !== mid) {
    let t = arr[mid];
    arr[mid] = arr[largest];
    arr[largest] = t;
    Heap(arr, largest, heapSize);
  }
}
```

4. [冒泡排序](https://blog.csdn.net/kir_77/article/details/110260821)

> 假设当前是对数组进行升序排序，冒泡排序的思想是每次遍历将最大值放到数组的尾部，重复 n - 1 次，直到最后只剩下最后一个元素

```js
var MaoSort = function (nums) {
  // 以下基于结果为递增数列进行
  const n = nums.length;

  if (!n) {
    // 数组为空
    return [];
  }

  for (let i = 0; i < n - 1; i++) {
    // 最坏进行 n 次
    let exchange = false;
    // 需要注意每次的终点都要减 1 索引
    for (let j = 0; j < n - 1 - i; j++) {
      // 每次都得到一个最大的数（后面都是有序的）
      if (nums[j + 1] < nums[j]) {
        exchange = true; // 优化策略
        let tmp = nums[j];
        nums[j] = nums[j + 1];
        nums[j + 1] = tmp;
      }
    }
    if (!exchange) {
      return nums;
    }
  }

  return nums;
};
```

5. [插入排序](https://blog.csdn.net/HumorChen99/article/details/113997634)

> 插入排序的基本思想是假设第一个记录是一个有序的序列，其余的记录为无序序列，从第二个记录开始，按照记录的大小依次将当前处理的记录插入到之前的有序序列中，直至最后一个记录插入到有序序列中为止。

```js
const InsertSort = function (nums) {
  let n = nums.length;

  for (let i = 1; i < n; i++) {
    // 比较 n- 1次
    for (let j = i; j >= 1; j--) {
      // 从后往前
      if (nums[j] < nums[j - 1]) {
        let tmp = nums[j];
        nums[j] = nums[j - 1];
        nums[j - 1] = tmp;
      }
    }
  }
};
```

> 可使用二分搜索找到第一个比 nums[i] 大的元素进行优化

6. [选择排序](https://blog.csdn.net/qq_45667680/article/details/107400977)

> 选择排序基本的思想是从待排序列中每次选取一个最大或者最小的元素放到当前无序序列的头部，循环进行 n - 1 次，得到就是一个有序数组

```js
var SelectSort = function (nums) {
  // 每一趟选择最小或者最大的放到对应位置
  // 以下基于结果是升序排列

  const n = nums.length;
  let min_index;

  for (let i = 0; i < n; i++) {
    min_index = i;
    for (let j = i; j < n; j++) {
      if (nums[j] < nums[min_index]) {
        // 加了等号就不是稳定的排序算法了
        min_index = j;
      }
    }
    let tmp = nums[min_index];
    nums[min_index] = nums[i];
    nums[i] = tmp;
  }
};
```

7. [希尔排序](https://www.cnblogs.com/l199616j/p/10740165.html)

> 希尔排序的基本思想是：先将整个待排序序列分割成若干个子序列，在子序列分别进行直接插入排序，待整个序列基本有序时，再对整体序列进行一次插入排序

```js
const XierSort = function (nums) {
  const n = nums.length;
  for (let step = Math.floor(n / 2); step >= 1; step = Math.floor(step / 2)) {
    for (let i = step; i < n; i++) {
      // 每趟都向前 step 步
      let [j, tmp] = [i, nums[i]];
      while (j - step >= 0 && nums[j - step] > tmp) {
        // 相当于只进行一轮 & 交换过程
        nums[j] = nums[j - step];
        j -= step;
      }
      nums[j] = tmp;
    }
  }
};
```

## 二、专题之二分搜索

> 二分搜索最简单的一种就是给定一个值在一个有序数组中查找判断该元素是否在这个有序数组中，在的会返回对应的索引下标，否则返回 -1。但是实际拓展起来有很多种查找情况。假定当前需要查找的目标数为 target，情况如下分析（**基于 left = 0 , right = a.length - 1**）：

1. 找到有序数组中第一个等于 target 的元素下标

```js
while (left <= right) {
  // mid 定义
  if (target <= a[mid]) {
    right--;
  } else if (target > a[mid]) {
    left++;
  }

  // 最后有三种情况
  // 第一. 查找到右边界  right == a.length - 1 left == a.length
  // (解决 left 越界)
  // 第二. 查找到左边界  right == -1 left = 0
  // (可能满足需要 a[left] 是否等于 target)
  // 第三，存在符合条件的情况此时最小的元素对应着 left 下标的元素
  if (left >= a.length || a[left] !== target) {
    return -1;
  }
  return a[left];
}
```

2. 找到有序数组中最后一个等于 target 的元素下标

```js
while (left <= right) {
  // mid 定义
  if (target < a[mid]) {
    right--;
  } else if (target >= a[mid]) {
    left++;
  }

  // 同样最后有三种情况
  // 第一. 查找到右边界  right == a.length - 1 left == a.length
  // (可能满足需要 a[right] 是否等于 target)
  // 第二. 查找到左边界  right == -1 left = 0
  // (解决 right 越界)
  // 第三，存在符合条件的情况此时最小的元素对应着 right 下标的元素
  if (right < 0 || a[right] !== target) {
    return -1;
  }
  return a[right];
}
```

3. 查找有序数组中最小并且大于 target 元素的下标

```js
let left = 0,
  right = nums.length - 1,
  mid = 0;

while (left <= right) {
  mid = Math.floor(left + (right - left) / 2);
  if (nums[mid] <= target) {
    // 1. 如果 target >= nums[mid] 向右缩小搜索空间
    left = mid + 1;
  } else if (nums[mid] > target) {
    right = mid - 1;
  }
}

return left; // 不存在返回的是 nums.length（所有元素都小于等于 target）
```

4. 查找有序数组中最大并且小于 target 元素的下标

```js
if (nums.length === 0) return -1;

let left = 0,
  right = nums.length - 1,
  mid = 0;

while (left <= right) {
  mid = Math.floor(left + (right - left) / 2);
  if (nums[mid] >= target) {
    // 1. 如果 target <= nums[mid] 向左缩小搜索空间
    right = mid - 1;
  } else if (nums[mid] < target) {
    left = mid + 1;
  }
}

return right; // 不存在就是返回 -1(所有元素都大于等于 target)
```

```javascript
/**
 * 力扣 878 题目
 * 神奇数字是能被 aaa 或 bbb 整除的正整数。
 */

function nthMagicalNumber(n, a, b) {
  const MOD = 1e9 + 7;
  // 二分查找(无限趋近于目标点)
  let l = Math.min(a, b);
  let r = n * Math.min(a, b);
  let lcm_a_b = lcm(a, b);
  let mid;
  while (l <= r) {
    mid = Math.floor((r - l) / 2 + l);
    // 减是为了排除是最大公倍数的倍数的情况
    let tar =
      Math.floor(mid / a) + Math.floor(mid / b) - Math.floor(mid / lcm_a_b);
    if (tar >= n) {
      r = mid - 1;
    } else {
      l = mid + 1;
    }
  }
  return (r + 1) % MOD;
  // return l % MOD 两者是一致的
}

/**
 * 最小公倍数的运算
 */
function lcm(a, b) {
  return Math.floor((a * b) / gcd(a, b));
}

/**
 * 最大公约数的运算
 */
function gcd(a, b) {
  // 辗转相除法
  return b !== 0 ? gcd(b, a % b) : a;
}

console.log(nthMagicalNumber(5, 2, 4));
```

```javascript
/**
 * 力扣 1201 题目
 * 丑数是可以被 a 或 b 或 c 整除的 正整数
 */

function nthUglyNumber(n, a, b, c) {
  const lcm = (a, b) => {
    return Math.floor((a * b) / gcd(a, b));
  };
  const gcd = (a, b) => {
    return b !== 0 ? gcd(b, a % b) : a;
  };

  let l = Math.min(a, b, c);
  let r = n * Math.min(a, b, c);
  let mid;
  let lcm_a_b = lcm(a, b),
    lcm_a_c = lcm(a, c),
    lcm_b_c = lcm(b, c);

  while (l <= r) {
    mid = Math.floor((l + r) / 2);
    let tar =
      Math.floor(mid / a) +
      Math.floor(mid / b) +
      Math.floor(mid / c) -
      Math.floor(mid / lcm_a_b) -
      Math.floor(mid / lcm_b_c) -
      Math.floor(mid / lcm_a_c) +
      Math.floor(mid / lcm(a, lcm(b, c)));
    if (tar >= n) {
      r = mid - 1;
    } else {
      l = mid + 1;
    }
  }
  return r + 1;
}

console.log(nthUglyNumber(3, 2, 3, 5));
console.log(nthUglyNumber(5, 2, 3, 3));
console.log(nthUglyNumber(6, 2, 1, 3));
console.log(nthUglyNumber(26, 14, 25, 14));
console.log(nthUglyNumber(7, 7, 7, 7));
```

上面两道题目其实思路是一样的，利用 `容斥原理` & `二分搜索` 来对数轴空间进行放缩

- 容斥原理体现在“或” 的情况可能出现交集的情况下排除交集
- 二分搜索体现在确定左右边界的情况下通过判断不断逼近最后的结果

---

> bfs & dfs 相关

网易的面试中有涉及到这一部分的内容，使用栈和队列来实现这两种方式，但是之前并没有太重视这个方向的学习导致回答上存在一定的偏差，所以还是需要去理解一下这方面的内容。

:star: 广度优先搜索 & 队列

```js
// 遍历图防止出现循环引用(图很可能出现 a指向 b 且 b 又指向 a 的情况)
BFS(u){
    queue q;
    将q入队;
    flag[u] = true; //u已被加入队列(非树遍历的关键；常常会在原数组中修改来替换操作)
    while(q非空){
        取出队首元素u进行访问;
        for(从u出发可达的所有顶点){
            if(flag[u]==false){//如果u未曾加入过队列
            将v入队;
            flag[u] = true;
            }
        }
    }
}

// 如果是基于树的遍历的话其实并不需要一个flag哈希表来判断是否重复的情况
```

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */

var bfs = function (grid, x, y) {
  const queue = [],
    n = grid.length,
    m = grid[0].length;
  queue.push([x, y]);
  while (queue.length) {
    let [i, j] = queue.pop();
    grid[i][j] = "0"; // 避免重复访问；本质上是使用这个操作来替换哈希表
    // 每次都判断当前层是否还存在为 1 的节点
    if (i - 1 >= 0 && +grid[i - 1][j] == 1) {
      queue.push([i - 1, j]);
    }
    if (i + 1 < n && +grid[i + 1][j] == 1) {
      queue.push([i + 1, j]);
    }
    if (j - 1 >= 0 && +grid[i][j - 1] == 1) {
      queue.push([i, j - 1]);
    }
    if (j + 1 < m && +grid[i][j + 1] == 1) {
      queue.push([i, j + 1]);
    }
  }
};

var numIslands = function (grid) {
  let count = 0;
  const n = grid.length,
    m = grid[0].length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      // 存在才进入 bfs 的判断
      if (+grid[i][j] == 1) {
        count++;
        bfs(grid, i, j);
      }
    }
  }
  return count;
};
```

[752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)

```js
var openLock = function (deadends, target) {
  if (target === "0000") {
    return 0;
  }

  const dead = new Set(deadends);
  if (dead.has("0000")) {
    return -1;
  }

  let step = 0;
  const queue = [];
  queue.push("0000");
  const seen = new Set();
  seen.add("0000");

  while (queue.length) {
    ++step;
    const size = queue.length;
    for (let i = 0; i < size; ++i) {
      const status = queue.shift();
      for (const nextStatus of get(status)) {
        if (!seen.has(nextStatus) && !dead.has(nextStatus)) {
          if (nextStatus === target) {
            return step;
          }
          queue.push(nextStatus);
          seen.add(nextStatus);
        }
      }
    }
  }

  return -1;
};

const numPrev = (x) => {
  return x === "0" ? "9" : parseInt(x) - 1 + "";
};

const numSucc = (x) => {
  return x === "9" ? "0" : parseInt(x) + 1 + "";
};

// 枚举 status 通过一次旋转得到的数字
const get = (status) => {
  const ret = [];
  const array = Array.from(status);
  for (let i = 0; i < 4; ++i) {
    const num = array[i];
    array[i] = numPrev(num);
    ret.push(array.join(""));
    array[i] = numSucc(num);
    ret.push(array.join(""));
    array[i] = num;
  }

  return ret;
};
```

## 三、专题之栈 & 队列

[622. 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)

:star: 题目有坑的地方在判断一些边界条件的时候，因为我们的元素中可能存在 0，所以不能简单使用 if(xxx) 去判断，这也是为什么我们在 deQueue 的时候使用 undefined 去替代。

```js
var MyCircularQueue = function (k) {
  this.front = 0;
  this.rear = 0;
  this.max = k;
  this.list = Array(k);
};

MyCircularQueue.prototype.enQueue = function (value) {
  if (this.isFull()) {
    return false;
  } else {
    this.list[this.rear] = value;
    this.rear = (this.rear + 1) % this.max; // 循环回队头
    return true;
  }
};

MyCircularQueue.prototype.deQueue = function () {
  let v = this.list[this.front];
  this.list[this.front] = undefined;
  if (v !== undefined) {
    // 不能使用 if(v)
    this.front = (this.front + 1) % this.max;
    return true;
  } else {
    return false;
  }
};

MyCircularQueue.prototype.Front = function () {
  if (this.list[this.front] === undefined) {
    return -1;
  } else {
    return this.list[this.front];
  }
};

MyCircularQueue.prototype.Rear = function () {
  let rear = this.rear - 1; // 因为 rear 代表的是当前最后一个下标的下一个索引
  // rear = - 1代表着循环了一轮了，所以取的是 this.max - 1
  if (this.list[rear < 0 ? this.max - 1 : rear] === undefined) {
    return -1;
  } else {
    return this.list[rear < 0 ? this.max - 1 : rear];
  }
};

MyCircularQueue.prototype.isEmpty = function () {
  // 需要排除循环一轮之后的情况
  return this.front === this.rear && !this.list[this.front];
};

MyCircularQueue.prototype.isFull = function () {
  // 同样的需要排除把所有元素都删掉的情况
  return this.front === this.rear && this.list[this.front] != undefined;
};
```

[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```js
// 借用辅助栈来实现 - 整体而言对于辅助栈类题目还是有时候存在一些问题
// 主要还是得从栈的特性思考问题再深入一些
// 题目的思路就是每次 push 的时候都往辅助栈放置最小的元素
var MinStack = function () {
  this.stackA = [];
  this.stackB = []; // 一开始放置无穷大是因为第一个push的元素肯定是最小的
};

MinStack.prototype.push = function (val) {
  this.stackA.push(val);
  // 栈顶永远保持是最小的元素
  if (!this.stackB.length || val <= this.stackB[this.stackB.length - 1]) {
    this.stackB.push(val);
  }
};

MinStack.prototype.pop = function () {
  const val = this.stackA.pop();
  // 出栈的时候判断是不是当前最小的元素；是的话也出栈
  if (val === this.stackB[this.stackB.length - 1]) {
    this.stackB.pop();
  }
};

// 返回当前栈顶值
MinStack.prototype.top = function () {
  return this.stackA[this.stackA.length - 1];
};

// 返回当前栈中最小的元素
MinStack.prototype.getMin = function () {
  return this.stackB[this.stackB.length - 1];
};
```

:star: 上面的做法是使用到了一个辅助栈，我们叫它最小栈。

```js
// 除了正常栈外使用常数空间
// 可通过例子 -2 0 -3 push push push pop pop pop 去理解
// 下次肯定会忘记这种思路的
var MinStack = function () {
  this.stack = [];
  this.minVal = -1; // 维护一个最小值
};

MinStack.prototype.push = function (val) {
  if (this.stack.length == 0) {
    // 初始
    this.stack.push(0);
    this.minVal = val;
  } else {
    // 不断更新 minVal 的过程
    let diff = val - this.minVal;
    // 不设置 = 其实也是 ok 的
    if (diff <= 0) this.minVal = val;
    this.stack.push(diff);
    // 这样想：如果diff是正数说明 val 大于 minVal
    // 如果 diff 是0或负数说明 val 小于等于 minVal
  }
};

MinStack.prototype.pop = function () {
  let val = this.stack.pop();
  // 更新 minVal
  if (val <= 0) {
    this.minVal = this.minVal - val;
  }
};

MinStack.prototype.top = function () {
  let val = this.stack[this.stack.length - 1];
  // 根据差值返回真实值的过程
  if (val <= 0) {
    return this.minVal;
  } else {
    return this.minVal + val;
  }
};

MinStack.prototype.getMin = function () {
  return this.minVal;
};
```

```js
// 单调栈对应的模版分析
vector<int> nextGreaterElement(vector<int>& nums) {
    vector<int> res(nums.size()); // 存放答案的数组
    stack<int> s;
    // 倒着往栈里放
    for (int i = nums.size() - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.empty() && s.top() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的 next great number
        res[i] = s.empty() ? -1 : s.top();
        s.push(nums[i]);
    }
    return res;
}
```

### 单调栈

单调栈指的是从栈顶到栈底的元素是严格递增或者严格递减的(注意方向是从栈顶到栈底)

- 对于单调递增栈，若当前进栈元素为 e，从栈顶开始遍历元素，把小于 e 或者等于 e 的元素弹出栈，直接遇到一个大于 e 的元素或者栈为空为止，然后再把 e 压入栈中。
- 对于单调递减栈，则每次弹出的是大于 e 或者等于 e 的元素。

<img src="https://labuladong.gitee.io/algo/images/%e5%8d%95%e8%b0%83%e6%a0%88/1.jpeg" style="display: block; margin: auto;"/>

单调栈的思路是从后遍历，如果遇到比栈顶大的元素就将当前栈的元素出栈，保持当前栈中的元素是按次序排列这样子就很容易找到当前位置的下一个最大位置。

给你一个数组 nums，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。输入一个数组 nums = [2,1,2,4,3] 返回数组 [4,2,4,-1,-1]。

<img src="E:\杂七杂八的东西\typeorm 图片存储区\image-20220415231906089.png" style="display: block; margin: auto;"/>

[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

```js
// 与上面的区别就是返回的是距离数组而不是值数组
var dailyTemperatures = function (temperatures) {
  const res = [],
    stack = [];
  for (let s = temperatures.length - 1; s >= 0; s--) {
    while (
      stack.length &&
      temperatures[s] >= temperatures[stack[stack.length - 1]]
    ) {
      stack.pop(); // 出栈
    }
    res[s] = stack.length ? stack[stack.length - 1] - s : 0;
    stack.push(s);
  }
  return res;
};
```

[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

```js
var nextGreaterElements = function (nums) {
  const res = [], // 存储对应的结果
    stack = []; // 存储栈

  let n = nums.length;
  for (let i = 2 * n - 1; i >= 0; i--) {
    while (stack.length && nums[i % n] >= stack[stack.length - 1]) {
      stack.pop();
    }
    // 关键在于 mod 的操作(因为要进行数据的更新)
    // 3 -3 2 3 翻倍后编程 3 -3 2 3 3 -3 2 3
    // 我们实际需要的只是前 4 个
    res[i % n] = stack.length ? stack[stack.length - 1] : -1;
    stack.push(nums[i % n]);
  }
  return res;
};
```

:star: 基于上面这个题目改造一下，如果每日温度也存在说循环数组的情况如何进行计算

```js
/**
 * 单调栈实现每日温度(考虑循环数组的情况)
 */
var dailyTemperatures = function (temperatures) {
  const res = [],
    stack = []; // 存储的是索引
  let n = temperatures.length;
  for (let i = 2 * n - 1; i >= 0; i--) {
    // 因为存储的是索引，i 需要进行 % n,同时 stack 的 top 也要 % n
    while (
      stack.length &&
      temperatures[i % n] >= temperatures[stack[stack.length - 1] % n]
    ) {
      stack.pop();
    }
    res[i % n] = stack.length ? stack[stack.length - 1] - i : 0;
    stack.push(i); // 每次将当前对比元素入栈
  }
  return res;
};
```

<img src="E:\杂七杂八的东西\typeorm 图片存储区\image-20220416000030955.png" style="display: block; margin: auto;"/>

### 单调队列

单调队列指的是从从队头到队尾的元素是严格递增或者严格递减的(注意方向是从队头到队尾)

如何维护单调队列？设计单调队列的时候，pop 和 push 需要保持一定的规则

1. pop(value)：如果窗口移除的元素 value 等于单调队列的出口元素，那么队列弹出元素，否则不用做任何操作
2. push(value)：如果 push 的元素 value 大于入口元素的数值，那么就将队列入口的元素弹出，直到 push 的元素数值小于等于队列入口的元素数值为止

保持如上的规则，每次窗口移动的时候，只要访问 queue.front 就可以返回当前窗口的最大值(如果是最小值的话我们可以修改一下上面的入队出队的策略)

[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

:star: 非常经典的问题，逆波兰表达式其实也叫后缀表达式，但是如何把正常表达式转化为后缀表达式呢

```js
var evalRPN = function (tokens) {
  const stack = [],
    n = tokens.length;
  for (let i = 0, item; (item = tokens[i]); i++) {
    if (!isNaN(Number(item))) {
      stack.push(Number(item));
    } else {
      // 取栈顶的两个元素进行计算
      let num1 = stack.pop(),
        num2 = stack.pop();
      num1 = +num1;
      num2 = +num2;
      if (item === "+") {
        stack.push(num2 + num1);
      } else if (item === "-") {
        stack.push(num2 - num1);
      } else if (item === "*") {
        stack.push(num2 * num1);
      }
      // 除法可能出现小数：分正数和负数两种情况处理
      else if (item === "/") {
        const r = num2 / num1;
        stack.push(r > 0 ? Math.floor(r) : Math.ceil(r));
      }
      //console.log(stack)
    }
  }
  return stack.pop();
};
```

中序表达式转为逆波兰表达式

[学习链接](http://c.biancheng.net/view/8297.html)

## 四、专题之 BFS

BFS 常见于树的遍历和最短路径的求解。在树的遍历中，常见的就是使用队列存储进行层次遍历的过程，因为在树中不存在逆向的过程因此很少出现出现循环引用的情况（已经处理过的节点再次出现）。但是在最短路径的求解中，其实很多时候给的是一种隐含无向图的情况，所以很多时候需要判断当前节点是否已经处理过了，否则很容易出现循环引用的情况导致程序的堆栈溢出无法正常运行。常见的处理就是建一个 hash 表来存储标识当前节点的状态，通过状态标识判断是否需要加入判断。

[知乎 bfs 说明](https://zhuanlan.zhihu.com/p/136183284#:~:text=BFS%20%E7%9A%84%E5%BA%94%E7%94%A8%E4%BA%8C%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.%20%E5%9C%A8%E4%B8%80%E6%A3%B5%E6%A0%91%E4%B8%AD%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%EF%BC%8C%E4%BD%86%E5%9C%A8%E5%9B%BE%E4%B8%AD%EF%BC%8C%E7%BB%93%E7%82%B9%E4%B9%8B%E9%97%B4%E5%8F%AF%E8%83%BD%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%93%AA%E6%9D%A1%E8%B7%AF%E6%9C%80%E8%BF%91%E5%91%A2%EF%BC%9F.%20%E8%BF%99%E4%B8%80%E7%B1%BB%E9%97%AE%E9%A2%98%E7%A7%B0%E4%B8%BA%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%20%E3%80%82.%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E4%B9%9F%E6%98%AF%20BFS,%E4%BB%8E%E6%BA%90%E7%82%B9%E5%87%BA%E5%8F%91%EF%BC%8CBFS%20%E9%A6%96%E5%85%88%E9%81%8D%E5%8E%86%E5%88%B0%E7%AC%AC%E4%B8%80%E5%B1%82%E7%BB%93%E7%82%B9%EF%BC%8C%E5%88%B0%E6%BA%90%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB%E4%B8%BA%201%EF%BC%8C%E7%84%B6%E5%90%8E%E9%81%8D%E5%8E%86%E5%88%B0%E7%AC%AC%E4%BA%8C%E5%B1%82%E7%BB%93%E7%82%B9%EF%BC%8C%E5%88%B0%E6%BA%90%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB%E4%B8%BA%202%E2%80%A6%E2%80%A6.%20%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E7%94%A8%20BFS%20%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%B7%9D%E7%A6%BB%E6%BA%90%E7%82%B9%E6%9B%B4%E8%BF%91%E7%9A%84%E7%82%B9%E4%BC%9A%E5%85%88%E8%A2%AB%E9%81%8D%E5%8E%86%E5%88%B0%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E8%83%BD%E6%89%BE%E5%88%B0%E5%88%B0%E6%9F%90%E4%B8%AA%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BA%86%E3%80%82.%20%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.)

### 单向 BFS

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

![bfs.png](https://pic.leetcode-cn.com/1603831235-YqYEUJ-bfs.png)

```js
// 根据上图的思路；每一层都可以枚举不同情况且情况可能相同
var numSquares = function (n) {
  const queue = [0],
    visited = [];
  let level = 0;
  while (queue.length) {
    level++;
    const size = queue.length;
    for (let j = 0; j < size; j++) {
      const cur = queue.shift(); // 使用 pop 会出现层次不一致的情况
      // 举个例子: 到第一层9出队入队11，马上就出队 11 不能保证同一层的 1 / 4 节点访问完成
      for (let i = 1; i * i + cur <= n; i++) {
        // 从1,2,3... 枚举直到 i * i + cur <= n时
        const next = i * i + cur;
        if (next === n) {
          // 相等则返回当前的层次代表叠加的次数
          return level;
        }
        if (!visited.includes(next)) {
          // 去除相同的情况比如 2*2+1 和 1*1+4 都是 5
          visited.push(next);
          queue.push(next);
        }
      }
    }
  }

  return level;
};
```

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */

var bfs = function (grid, x, y) {
  const queue = [],
    n = grid.length,
    m = grid[0].length;
  queue.push([x, y]);
  while (queue.length) {
    let [i, j] = queue.pop();
    grid[i][j] = "0"; // 避免重复访问；本质上是使用这个操作来替换哈希表
    // 每次都判断当前层是否还存在为 1 的节点
    if (i - 1 >= 0 && +grid[i - 1][j] == 1) {
      queue.push([i - 1, j]);
    }
    if (i + 1 < n && +grid[i + 1][j] == 1) {
      queue.push([i + 1, j]);
    }
    if (j - 1 >= 0 && +grid[i][j - 1] == 1) {
      queue.push([i, j - 1]);
    }
    if (j + 1 < m && +grid[i][j + 1] == 1) {
      queue.push([i, j + 1]);
    }
  }
};

var numIslands = function (grid) {
  let count = 0;
  const n = grid.length,
    m = grid[0].length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      // 存在才进入 bfs 的判断
      if (+grid[i][j] == 1) {
        count++;
        bfs(grid, i, j);
      }
    }
  }
  return count;
};
```

### 双向 BFS

双向 BFS 其实解决了搜索空间爆炸的问题，举个例子就是在力扣[127. 单词接龙](https://leetcode.cn/problems/word-ladder/) 这道题目里面，startWord 最大的单词长度是 10，因为每个字符又可以替换为 26 个字母的其余字母，因此实际一个 startWord 可以产生的单词数就有 10 \* 25，如果不断迭代下去的话搜索空间就会变成 25^n 指数阶的大小，很容易就导致堆栈溢出了。双向 BFS 的原理其实就是从两端进行搜索（可以理解为是一端从前端往后端开始搜索，一端从后端往前端开始搜索），那么搜索空间实际就被缩小很多了。

![image.png](https://pic.leetcode-cn.com/1623894976-CCMljJ-image.png)

:key: 伪代码实现

```java
d1、d2 为两个方向的队列
m1、m2 为两个方向的哈希表，记录每个节点距离起点的

// 只有两个队列都不空，才有必要继续往下搜索
// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点
while(!d1.isEmpty() && !d2.isEmpty()) {
    if (d1.size() < d2.size()) {
        update(d1, m1, m2);
    } else {
        update(d2, m2, m1);
    }
}

// update 为将当前队列 d 中包含的元素取出，进行「一次完整扩展」的逻辑（按层拓展）
void update(Deque d, Map cur, Map other) {}
```

[127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

```js
// 单向 bfs实现
var ladderLength = function (beginWord, endWord, wordList) {
  // 创建集合数组 -> 后续使用集合数组的方法
  let wordSet = new Set(wordList);
  // 若数组中无最终字符串 -> 返回0
  if (!wordSet.has(endWord)) return 0;
  // 初始化放入队列
  let queue = [[beginWord, 1]];
  // 当队列不为空
  while (queue.length) {
    // 提取队首
    let [word, sum] = queue.pop();
    // 如果当前字符串就是最终字符串 -> 返回步数
    if (word === endWord) return sum;
    // 遍历当前字符串和集合数组所有相差1字符的情况
    for (let str of wordSet) {
      if (strDiff(word, str) === 1) {
        // 放入队尾
        queue.unshift([str, sum + 1]);
        // 避免重复放入
        wordSet.delete(str);
      }
    }
  }
  // 当不需要转换时
  return 0;
};
// 判断字符串不同
const strDiff = (str1, str2) => {
  let changes = 0;
  for (let i = 0; i < str1.length; i++) {
    if (str1[i] != str2[i]) changes += 1;
  }
  return changes;
};
```

:key: 总结来说哦

1. 建立两个队列分别存储前后遍历的节点
2. 建立两个哈希表存储前后遍历到的节点演化的次数(从前节点演化到当前节点所需要的次数)
3. 哈希表需要节点是否已经访问

```js
// 双向 bfs (但是不能全部通过测试用例)
function update(
  queue = [],
  startMap = new Map(),
  endMap = new Map(),
  set = new Set()
) {
  let size = queue.length;
  while (size--) {
    const s = queue.shift();
    for (let i = 0; i < s.length; i++) {
      const t = s.split("");
      // 断对当前的字符串进行替换(JS 的字符串是不能被直接修改的)
      for (let j = 97; j <= 122; j++) {
        t[i] = String.fromCharCode(j);
        const currS = t.join(""); // 得到更新后的字符串
        if (!set.has(currS)) {
          continue;
        }
        // 对是否访问过来进行判断了(后面的判断是为了防止原字符被跳过判断)
        if (startMap.has(currS)) {
          continue;
        }
        if (endMap.has(currS)) {
          // 说明找到了
          return startMap.get(s) + endMap.get(currS) + 1;
        }
        startMap.set(currS, startMap.get(s) + 1);
        queue.push(currS);
      }
    }
  }
  return -1;
}

function ladderLength(beginWord = "", endWord = "", wordList = []) {
  //?双向 bfs 搜索(这里单向的话搜索空间很可能会爆炸)
  // 创建集合表(搜索的时间复杂度为 o(1))
  const set = new Set();
  for (const item of wordList) {
    set.add(item);
  }
  if (!set.has(endWord)) {
    return 0;
  }
  const startQueue = [];
  const endQueue = [];

  // map 主要是存储当前路径由原始路径演化的次数
  const startMap = new Map();
  const endMap = new Map();

  // 初始化相关数据
  startQueue.push(beginWord);
  endQueue.push(endWord);
  startMap.set(beginWord, 0);
  endMap.set(endWord, 0);

  let t = -1;
  while (startQueue.length && endQueue.length) {
    if (startQueue.length <= endQueue.length) {
      // 从 start 开始搜索
      t = update(startQueue, startMap, endMap, set);
    } else {
      //从 end 开始搜索
      t = update(endQueue, endMap, endMap, set);
    }
    if (t !== -1) {
      return t + 1;
    }
  }
  return 0;
}
```

[433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)

```js
var minMutation = function (start, end, bank) {
  const cnt = new Set();
  const visited = new Set();
  const keys = ["A", "C", "G", "T"];
  for (const w of bank) {
    cnt.add(w);
  }
  if (start === end) {
    return 0;
  }
  if (!cnt.has(end)) {
    return -1;
  }
  const queue = [start];
  visited.add(start);
  let step = 1;
  while (queue.length) {
    const sz = queue.length;
    for (let i = 0; i < sz; i++) {
      const curr = queue.shift();
      for (let j = 0; j < 8; j++) {
        for (let k = 0; k < 4; k++) {
          if (keys[k] !== curr[j]) {
            const sb = [...curr];
            sb[j] = keys[k];
            const next = sb.join("");
            if (!visited.has(next) && cnt.has(next)) {
              if (next === end) {
                return step;
              }
              queue.push(next);
              visited.add(next);
            }
          }
        }
      }
    }
    step++;
  }
  return -1;
};
```

### 多源 BFS

[太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

```javascript
function pacificAtlantic(heights = []) {
  // 其实换位理解下题目的意思就是说求两个海洋可以流向格子的交集
  const m = heights.length,
    n = heights[0].length;

  const res1 = Array.from(Array(m), () => Array(n).fill(0));
  const res2 = Array.from(Array(m), () => Array(n).fill(0));

  const queue1 = [],
    queue2 = [];
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      // 加入太平洋
      if (i === 0 || j === 0) {
        queue1.push([i, j]);
        res1[i][j] = true;
      }
      // 加入大西洋
      if (i === m - 1 || j === n - 1) {
        queue2.push([i, j]);
        res2[i][j] = true;
      }
    }
  }

  const bfs = (queue, res) => {
    const pos = [
      [0, 1],
      [0, -1],
      [1, 0],
      [-1, 0],
    ];
    while (queue.length) {
      const [x, y] = queue.shift();
      for (let i = 0; i < 4; i++) {
        let p = x + pos[i][0],
          q = y + pos[i][1];
        if (p < 0 || q < 0 || p >= m || q >= n) {
          continue;
        }
        // 为什么要进行这个判断呢? 首先要判断能不能流向海洋那么当前这个格子的高度必然是要大于前者
        // 否则必然无法流向海洋
        if (res[p][q] || heights[p][q] < heights[x][y]) { // 关键点
          continue;
        }
        queue.push([p, q]);
        res[p][q] = 1h
      }
    }
  };

  // 多源 bfs 查找
  bfs(queue1, res1);
  bfs(queue2, res2);

  // 得到两个集合后求两个集合的交集
  const ans = [];
  for (let i = 0; i < res1.length; i++) {
    for (let j = 0; j < res1[0].length; j++) {
      if (res1[i][j] && res2[i][j]) {
        ans.push([i, j]);
      }
    }
  }
  return ans;
}

console.log(
  pacificAtlantic([
    [1, 2, 2, 3, 5],
    [3, 2, 3, 4, 4],
    [2, 4, 5, 3, 1],
    [6, 7, 1, 4, 5],
    [5, 1, 1, 2, 4],
  ])
);

```

## 五、专题之 DFS

传统的 DFS 是使用递归的方式来实现前序 / 中序 / 后序遍历，使用递归的话如果深度过大可能会导致堆栈溢出，所以我们可以使用栈来实现迭代的遍历。使用栈的原因是当我们回溯的时候，最后进入的节点会最先弹出，符合 LIFO 的特点。

### 传统的递归遍历

```java
/*
 * 传统递归遍历的模版
 * Return true if there is a path from cur to target.
 */
boolean DFS(Node cur, Node target, Set<Node> visited) {
    return true if cur is target; // 符合条件直接返回
    for (next : each neighbor of cur) { // 遍历邻接点
        if (next is not in visited) { // 判断是否有访问过
            add next to visted;  // 如果没有那么就添加进入 visited
            return true if DFS(next, target, visited) == true; // 进行深层递归
        }
    }
    return false;
}
```

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

还是岛屿数量的问题，之前是用广度优先搜索来解决的，现在用深度优先搜索

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */

const dp = [
  [-1, 0],
  [1, 0],
  [0, -1],
  [0, 1],
];
var dfs = function (grid, i, j) {
  let m = grid.length,
    n = grid[0].length;
  for (let q = 0; q < 4; q++) {
    let i1 = i + dp[q][0],
      i2 = j + dp[q][1];
    if (i1 >= 0 && i1 < m && i2 >= 0 && i2 < n && +grid[i1][i2] === 1) {
      grid[i1][i2] = "0"; // 互斥条件
      dfs(grid, i1, i2);
    }
  }
};

var numIslands = function (grid) {
  let count = 0,
    m = grid.length,
    n = grid[0].length;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (+grid[i][j] === 1) {
        // 遇到 '1' 就深度搜索附近所有的区域直至全为 ''
        dfs(grid, i, j);
        count++;
      }
    }
  }
  return count;
};
```

[133. 克隆图](https://leetcode-cn.com/problems/clone-graph/)

```js
/**
 *
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function (node) {
  // 这里的输出对题目的理解有一定的帮助
  // console.log(node.val) // 1
  // console.log(node.neighbors) // [2: {val, neighbors}, 4: {val, neighbors}}]

  // 边界条件处理
  if (node == null) {
    return node;
  }

  const hashMap = new Map(); // 哈希列表用来存储已经创建的节点
  const dfs = (node) => {
    // 创建一个 node
    const newNode = new Node(node.val);
    hashMap.set(newNode.val, newNode); // 必须先存起来再进行后面的递归不然会出问题
    for (let i = 0, item; (item = node.neighbors[i++]); ) {
      if (hashMap.has(item.val)) {
        // 节点已经创建那么可以直接加入 neighbors 列表中
        newNode.neighbors.push(hashMap.get(item.val));
      } else {
        // 否则创建图节点；进行节点的递归操作；创建节点 -> 创建 neighbors 列表
        newNode.neighbors.push(dfs(item));
      }
    }
    return newNode;
  };

  return dfs(node);
};
```

[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

```js
var findTargetSumWays = function (nums, target) {
  let count = 0;
  const dfs = (index, sum) => {
    if (index == nums.length) {
      if (sum === target) {
        count++;
      }
      return;
    }

    // 枚举 +
    sum += nums[index];
    dfs(index + 1, sum);
    sum -= nums[index];

    // 枚举 -
    sum -= nums[index];
    dfs(index + 1, sum);
    sum += nums[index];
  };

  dfs(0, 0);

  return count;
};
```

### 使用栈进行优化

```java
/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(int root, int target) {
    Set<Node> visited;
    Stack<Node> s;
    add root to s;
    while (s is not empty) {
        Node cur = the top element in s;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to s;
                add next to visited;
            }
        }
        remove cur from s;
    }
    return false;
}
```

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

:star: 强迫自己使用栈 + DFS 的方式去实现(因为递归写起来简单但是永远不知道递归的深度在哪里)

<img src="https://assets.leetcode-cn.com/solution-static/94/6.png" style="display: block; margin: auto;"/>

基于上面的图

第一轮从 1 节点开始，先从左子树，将 2 入栈，将 4 入栈，随后 4 出栈；

第二轮由于 root.right 为 null 但是 stack 里面有 1, 2 所以会继续，于是 2 出栈；

第三轮 5 入栈，5 出栈；

第四轮 1 出栈，3 入栈，6 入栈

第五轮 6 出栈

第六轮 3 出栈

完成遍历的过程

```js
var inorderTraversal = function (root) {
  const stack = [],
    result = [];
  // 一开始的思路是 声明 stack [root]
  // 但是这样后面就不好操作了
  while (root || stack.length) {
    while (root) {
      stack.push(root);
      root = root.left; // 基于当前是中序遍历
    }
    root = stack.pop();
    result.push(root.val);
    root = root.right;
  }

  return result;
};
```

## 六、专题之栈 & 队列

### 简单应用

[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

:warning: 这道题有坑的一个地方是 peek 那里，必须是以 outStack 作为判断基准，因为存在这么一种情况，初始入栈了 1 2 3，执行 pop 方法，outStack = [3, 2], inStack = []。此时再 push 一个 4。outStack = [3, 2]，inStack = [4]，如果此时返回 inStack 的头元素 4 其实是不满足题意的，应该返回的是 2 ，也就是 outStack[outStack.length - 1]

```js
var MyQueue = function () {
  this.inStack = [];
  this.outStack = [];
};

MyQueue.prototype.push = function (x) {
  this.inStack.push(x);
};

MyQueue.prototype.pop = function () {
  if (!this.outStack.length) {
    this.in2out();
  }
  return this.outStack.pop();
};

MyQueue.prototype.peek = function () {
  // 有坑的地方需要注意
  if (!this.outStack.length) {
    this.in2out();
  }
  return this.outStack[this.outStack.length - 1];
};

MyQueue.prototype.empty = function () {
  return this.outStack.length === 0 && this.inStack.length === 0;
};

MyQueue.prototype.in2out = function () {
  while (this.inStack.length) {
    this.outStack.push(this.inStack.pop());
  }
};
```

[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

:warning: JS 中没有队列这样的数据结构，所以需要我们自己去用数组模拟。这道题的思路就是每次 push 的时候都将原数据出队，加入新的数据后再进行入队的操作，这样就能保证新入队的元素在队头能够首先出队，符合栈 LILO 的特点。需要注意在执行 top 方法的时候 stack 的栈顶对应的是 queue 的队头

```js
var MyStack = function () {
  this.queue = [];
};

/**
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function (x) {
  const t = [];
  if (this.queue.length > 0) {
    while (this.queue.length) {
      t.push(this.queue.shift());
    }
    this.queue.push(x);
    for (const item of t) {
      this.queue.push(item);
    }
  } else {
    this.queue.push(x);
  }
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function () {
  if (this.queue.length > 0) {
    return this.queue.shift();
  }
};

/**
 * @return {number}
 */
MyStack.prototype.top = function () {
  if (this.queue.length > 0) {
    return this.queue[0];
  }
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function () {
  return !this.queue.length;
};
```

[394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

:warning: 解题的时候解得很乱，栈的思维还是没有把握得特别好. 下次遇到肯定还是不会的

思路：碰到一个 '[' 就将数字和字符串加入对应的栈，目的是为了缓存上一步的一些计算参数，因为有 '[' 意味着就有下一步 repeat 的计算，这个也是这道题的关键。还有就是 result 变量，代表的是当前 repeat 轮次的字符串。

```js
const decodeString = (s) => {
  let numStack = []; // 存倍数的栈
  let strStack = []; // 存 待拼接的str 的栈
  let num = 0; // 倍数的“搬运工”
  let result = ""; // 字符串的“搬运工”
  for (const char of s) {
    // 逐字符扫描
    if (!isNaN(char)) {
      // 遇到数字
      num = num * 10 + Number(char); // 算出倍数
    } else if (char == "[") {
      // 遇到 [
      strStack.push(result); // result串入栈
      result = ""; // 入栈后清零
      numStack.push(num); // 倍数num进入栈等待
      num = 0; // 入栈后清零
    } else if (char == "]") {
      // 遇到 ]，两个栈的栈顶出栈
      let repeatTimes = numStack.pop(); // 获取拷贝次数
      result = strStack.pop() + result.repeat(repeatTimes); // 构建子串
    } else {
      result += char; // 遇到字母，追加给result串
    }
  }
  return result;
};
```

[733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)

```js
const dp = [
  [-1, 0],
  [1, 0],
  [0, 1],
  [0, -1],
];

const floodFill = (image, sr, sc, newColor) => {
  const m = image.length,
    n = image[0].length;

  /* 深度优先搜索 */
  const dfs = function (i, j, val) {
    if (i >= 0 && i < m && j >= 0 && j < n && image[i][j] === val) {
      image[i][j] = newColor;
      for (let p = 0; p <= 3; p++) {
        let next_i = i + dp[p][0],
          next_j = j + dp[p][1];
        dfs(next_i, next_j, val);
      }
    }
  };

  /* 广度优先搜索 */
  const bfs = function (i, j, val) {
    const queue = [[i, j]];
    while (queue.length) {
      const [i, j] = queue.shift();
      if (i >= 0 && i < m && j >= 0 && j < n && image[i][j] === val) {
        image[i][j] = newColor;
        for (let p = 0; p <= 3; p++) {
          let next_i = i + dp[p][0],
            next_j = j + dp[p][1];
          queue.push([next_i, next_j]);
        }
      }
    }
  };

  if (newColor === image[sr][sc]) {
    return image;
  }

  //dfs(sr, sc, image[sr][sc])
  bfs(sr, sc, image[sr][sc]);
  return image;
};
```

[542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

超级零点问题，将所有的 0 入栈并设置他们已访问。

超级零点问题就是从多个源点出现找最短路径的问题。

```js
/**
 * @param {number[][]} mat
 * @return {number[][]}
 */
var updateMatrix = function (mat) {
  // 多入口的广度优先搜索

  const m = mat.length,
    n = mat[0].length;
  const quene = [],
    distance = [],
    seen = [];
  const x = [-1, 1, 0, 0],
    y = [0, 0, 1, -1];

  for (let i = 0; i < m; i++) {
    distance[i] = Array(n).fill(0);
    seen[i] = Array(n).fill(0);
    for (let j = 0; j < n; j++) {
      if (mat[i][j] === 0) {
        quene.push([i, j]);
        seen[i][j] = 1; // 代表当前元素已经被访问过
      }
    }
  }

  const dfs = () => {
    while (quene.length > 0) {
      const [i, j] = quene.shift();
      for (let q = 0; q < x.length; q++) {
        //四周递归
        let rx = x[q] + i,
          ry = y[q] + j;
        if (rx >= 0 && ry >= 0 && rx < m && ry < n && !seen[rx][ry]) {
          distance[rx][ry] = distance[i][j] + 1;
          quene.push([rx, ry]);
          seen[rx][ry] = 1;
        }
      }
    }
  };

  dfs();

  return distance;
};
```

[841. 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)

```js
var canVisitAllRooms = function (rooms) {
  const n = rooms.length,
    dp = Array(n).fill(1);

  /* 广度优先搜索 */
  const bfs = (i) => {
    // 默认 dp[0] 永远是 1
    // 可以设置 dp[0] 初始为 0 那么判断的时候 sum 就等于
    const queue = [...rooms[i]];
    while (queue.length) {
      let room = queue.shift();
      dp[room] = 0;
      for (let i = 0, item; (item = rooms[room][i++]); ) {
        if (dp[item] === 1) {
          queue.push(item);
        }
      }
    }
  };

  bfs(0);
  return dp.reduce((prev, curr) => prev + curr, 0) === 1;

  /* 深度优先搜索 */
  const dfs = (i) => {
    dp[i] = 0;
    const items = rooms[i];
    for (const item of items) {
      if (dp[item] === 1) {
        dfs(item);
      }
    }
  };
  dfs(0);
  return dp.reduce((prev, curr) => prev + curr, 0) === 0;
};
```

### 单调栈

单调栈的定义：**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。算法的时间复杂度是 O(n)

在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？**一定要记住存储的是索引而不是值**

单调栈里只需要存放元素的下标 i 就可以了，如果需要使用对应的元素，直接 T[i]就可以获取。

2. 单调栈里元素是递增呢？ 还是递减呢？

单调栈的判断条件

- 当前遍历的元素 T[i]小于栈顶元素 T[st.top()]的情况
- 当前遍历的元素 T[i]等于栈顶元素 T[st.top()]的情况
- 当前遍历的元素 T[i]大于栈顶元素 T[st.top()]的情况

[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

```js
var dailyTemperatures = function (temperatures) {
  // 最近大元素的索引
  const n = temperatures.length;
  const answer = Array(n).fill(0);
  const stack = [0]; // 空间换时间
  for (let i = 1; i < n; i++) {
    while (
      stack.length &&
      temperatures[i] > temperatures[stack[stack.length - 1]]
    ) {
      const idx = stack.pop();
      answer[idx] = i - idx;
    }
    stack.push(i);
  }
  return answer;
};
```

[496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

```js
var nextGreaterElement = function (nums1, nums2) {
  const stack = [0]; // 存储的是下标
  const answer = Array(nums2.length).fill(-1);

  // 哈希表映射提升查找速度（建立在无重复元素的基础上）
  const map = new Map();
  for (const item in nums2) {
    map.set(nums2[item], item);
  }

  // 这里相比上面讲过程更详细了
  for (let i = 1; i < nums2.length; i++) {
    if (nums2[i] < nums2[stack[stack.length - 1]]) {
      stack.push(i);
    } else if (nums2[i] === nums2[stack[stack.length - 1]]) {
      stack.push(i);
    } else {
      while (stack.length && nums2[i] > nums2[stack[stack.length - 1]]) {
        // 注意这里记录的是元素所在的下标而不是距离
        const idx = stack.pop();
        answer[idx] = i;
      }
      stack.push(i);
    }
  }

  const idxs = [];
  for (let i = 0; i < nums1.length; i++) {
    const idx = map.get(nums1[i]);
    idxs[i] = answer[idx] === -1 ? -1 : nums2[answer[idx]];
  }
  return idxs;
};
```

[503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

```js
// 这道题卡了一会的原因是那些下标的地方没有注意
var nextGreaterElements = function (nums) {
  // 循环数组，那么重新拼接一个就好
  const items = [...nums, ...nums];
  const stack = [0];
  const rets = Array(items.length).fill(-1);
  for (let i = 1; i < items.length; i++) {
    if (items[i] <= items[stack[stack.length - 1]]) {
      stack.push(i);
    } else {
      while (stack.length && items[i] > items[stack[stack.length - 1]]) {
        const idx = stack.pop();
        rets[idx] = items[i];
      }
      stack.push(i);
    }
  }
  return rets.slice(0, nums.length);
};
```

:key: 老问题，就是一定要清楚 stack 里面放的是什么，还有就是 rets[idx] = items[i] 这里一定要非常注意，明白这里的含义是将不符合递增条件的下标进行赋值，进行赋值，进行赋值。

[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```js
var trap = function (height) {
  // 双指针 -- 按列进行计算
  let sum = 0;
  for (let i = 0; i < height.length; i++) {
    if (i === 0 || i === height.length - 1) {
      continue;
    }
    let leftMax = height[i - 1],
      rightMax = height[i + 1];
    for (let p = i - 1, q = i + 1; p >= 0 || q < height.length; p--, q++) {
      p >= 0 && (leftMax = Math.max(leftMax, height[p]));
      q < height.length && (rightMax = Math.max(rightMax, height[q]));
    }
    if (leftMax < height[i] || rightMax < height[i]) {
      continue;
    }
    sum += Math.min(leftMax, rightMax) - height[i];
  }
  return sum;
};
```

### 单调队列

应用场景：给你一个数组 window，已知其最值为 A，如果给 window 中添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值

```js
function maxSlidingWindow(nums = [], k) {
  // 单调队列(队列为一个递减顺序)
  // 队头存放着最大的值
  const q = [];
  for (let i = 0; i < k; i++) {
    while (q.length && nums[i] > nums[q[q.length - 1]]) {
      q.pop();
    }
    q.push(i); // 存储索引
  }

  const ans = [nums[q[0]]];
  for (let i = k; i < nums.length; i++) {
    while (q.length && nums[i] > nums[q[q.length - 1]]) {
      q.pop();
    }
    q.push(i);
    if (q[0] <= i - k) {
      // [1 2 7 4 5 6] k=3, i=5, 那么此时对应的应该是 4 5 6, 7就被删掉
      // 当前队头已从滑动窗口滑出
      q.shift();
    }
    ans.push(nums[q[0]]);
  }
  return ans;
}
```

## 七、专题之数组&字符串

:yellow_heart: 关键字：双指针；前缀和；滑动窗口；哈希表

[724. 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/) -- 前缀和

:star: 利用前缀和的思路，因为中心下标指的是左边的和 和 右边的和相等，那么对应他们应该是整个数组的和 - 中心值 / 2，一旦搜索过程中满足这样的情况就认为存在中心下标啦。

```js
var pivotIndex = function (nums) {
  const sum = nums.reduce((prev, curr) => prev + curr, 0); // 总和
  let leftSum = 0; // 前缀和
  for (let i = 0; i < nums.length; i++) {
    if (leftSum === (sum - nums[i]) / 2) {
      return i;
    }
    leftSum += nums[i];
  }
  return -1;
};
```

[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) -- 二分查找

:star: 二分查找的拓展应用，查找第一个比 target 的元素下标，其实就是最后的 left

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function (nums, target) {
  let left = 0,
    right = nums.length - 1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] > target) {
      right = mid - 1;
    } else if (nums[mid] < target) {
      left = mid + 1;
    }
  }
  return left; // 指向大于target的第一个元素
};
```

[27. 移除元素](https://leetcode-cn.com/problems/remove-element/) -- 双指针

:key: 本质上是使用同向双指针，fast 遇到 !== val 的时候停下来与 slow 交换数值使得 !== val 的元素排到前面从而不需要建立辅助空间。

```js
var removeElement = function (nums, val) {
  let slow = 0,
    fast = 0;
  for (; fast < nums.length; fast++) {
    if (nums[fast] === val) {
      continue;
    }
    nums[slow++] = nums[fast];
  }
  return slow;
};
```

[844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/) -- 双指针

```js
var backspaceCompare = function (S, T) {
  let i = S.length - 1,
    j = T.length - 1,
    skipS = 0,
    skipT = 0;
  // 大循环
  while (i >= 0 || j >= 0) {
    // S 循环
    while (i >= 0) {
      if (S[i] === "#") {
        skipS++;
      } else if (skipS > 0) {
        skipS--;
      } else {
        break;
      }
      i--;
    }
    // T 循环
    while (j >= 0) {
      if (T[j] === "#") {
        skipT++;
      } else if (skipT > 0) {
        skipT--;
      } else break;
      j--;
    }
    // 涵盖了当前字符串不相等 | 某个字符串已经出现越界的请款
    // 1. c !== a   false
    // 2. c !== undefined  false
    // 3. undefined !== undefined true
    if (S[i] !== T[j]) return false;
    i--;
    j--;
  }
  return true;
};
```

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

:star: 整体的思路：排序，目的是使得对应的左区间在列表中是有序的，定义前后两个指针，后指针先不断往后寻找重叠的区间，不断更新其中右区间的 max，直到找不到，将对应的结果加入到 rt 中。:key:随后最重要的一步就是更改 prev 指向到当前第一个不重叠的集合，然后继续前面的搜索过程。

```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function (intervals) {
  const n = intervals.length;
  const rt = [];
  let prev = 0,
    curr = 1;
  intervals.sort((a, b) => a[0] - b[0]);
  let max = intervals[0][1];
  for (; curr < n; curr++) {
    if (max >= intervals[curr][0]) {
      // 重叠
      max = Math.max(max, intervals[curr][1]); // 获得右区间
    } else {
      // 更新下一个不重叠的区间
      rt.push([intervals[prev][0], max]);
      max = intervals[curr][1];
      prev = curr;
    }
  }

  rt.push([intervals[prev][0], max]); // 循环结束后其实还有最后一项是没有处理的
  return rt;
};
```

[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

:star: 其实就是找旋转图像的规律，`matrix[row][col] = matrix[col][n-row-1]`，虽然可以说新建一个数组进行相应规律的赋值最后再统一映射回去。

```js
var rotate = function (matrix) {
  // 这道题的解法其实是由规律的
  // 第一行的第 j 个元素经过 90deg 旋转后会到最后一列的第 j 行；其他规律其实也是这样
  // matrix[row][col] = matrix[col][n-row-1]

  const n = matrix.length;
  const dp = Array.from(Array(n), () => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      dp[j][n - i - 1] = matrix[i][j];
    }
  }

  for (let i = 0; i < dp.length; i++) {
    matrix[i] = dp[i];
  }
  return matrix;
};
```

:key: 因此需要想办法在原数组上进行修改，可以使用翻转的方式代替旋转，通过翻转来构造对应的计算公式。

<img src="E:\杂七杂八的东西\typeorm 图片存储区\image-20220422222040842.png" style="display: block; margin: auto;"/>

```js
var rotate = function (matrix) {
  const n = matrix.length;
  // 水平翻转
  for (let i = 0; i < Math.floor(n / 2); i++) {
    for (let j = 0; j < n; j++) {
      // 解构赋值的形式翻转
      [matrix[i][j], matrix[n - i - 1][j]] = [
        matrix[n - i - 1][j],
        matrix[i][j],
      ];
    }
  }

  // 主对角线翻转
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < i; j++) {
      // 同样是解构赋值的形式
      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
    }
  }
};
```

[498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)

:key: 基本思路：先从简单的问题想起，不考虑对角线的遍历我们会怎么做？然后再在上面的基础上对某些对角线进行翻转其实就得到了题目的答案。

```js
var findDiagonalOrder = function (list) {
  if (list == null || list.len == 0) {
    return [];
  }

  let m = list.length,
    n = list[0].length;
  const res = [];
  let k = 0;

  // 遵循从右往左的遍历方式
  let t = [];
  for (let i = 0; i < m + n - 1; i++) {
    // 得到对角线的关键代码
    // 第一行的所有元素作为起点去进行遍历
    // 接着从第二行的末尾，第三行的末尾.... 一直到第 m 行的末尾进行遍历
    let r = i < n ? 0 : i - n + 1;
    let c = i < n ? i : n - 1;
    while (r < m && c > -1) {
      t.push(list[r][c]);
      ++r;
      --c;
    }

    if (i % 2 === 0) {
      t.reverse();
    }

    for (let j = 0; j < t.length; j++) {
      res[k++] = t[j];
    }
    t.length = 0;
  }

  return res;
};
```

[14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

:key: 这道题虽然是简单题，但是能带给我们很多解题的思路

- 横向查找 -- 第一个元素作为最长公共前缀然后不断迭代下去
- 纵向查找 -- 不断遍历数组元素的列直到有一个不相等
- 分治思想
- 二分搜索 -- 最短的那个字符串必然包含最多的公共子序列

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

:key:

- 双指针 -- 指针从中间出发向两边扩散
  - 怎么扩散？？？
  - 循环过程怎么处理？？？
  - :exclamation: 每遍历到一个字符串，都把它作为当前的中心进行扩散，因为中心可能是奇数也可能是偶数，所以需要枚举这两种情况使得对应的情况成立。
- 动态规划 ？？？

[151. 颠倒字符串中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

- 使用 JS 内部 API，按空格切割后直接 reverse 整个数组
- 自行思想上面这些 API
  - trim -- 对应的就是

### kmp

[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

- 暴力破解
  - 对 str 的每一个起点作为开始进行搜索
- KMP 算法
  - 寻找公共前缀后缀实现子串移动

```js
var strStr = function (haystack, needle) {
  // kmp 维护前缀表
  const next = Array(needle.length).fill(0);
  const getNext = (needle) => {
    let j = 0;
    for (let i = 1; i < needle.length; i++) {
      while (j > 0 && needle[i] !== needle[j]) {
        j = next[j - 1];
      }
      if (needle[i] === needle[j]) {
        j++;
      }
      next[i] = j;
    }
  };
  getNext(needle);

  // 利用 next 进行匹配
  if (needle.length === 0) {
    return 0;
  }
  let i = 0;
  for (let j = 0; j < haystack.length; ) {
    if (haystack[j] !== needle[i]) {
      if (i === 0) {
        j++;
      } else {
        i = next[i - 1];
      }
    } else if (haystack[j] === needle[i]) {
      i++;
      j++;
    }

    console.log(i);
    if (i === needle.length) {
      return j - needle.length;
    }
  }
  return -1;
};
```

### 滑动窗口

[相关练习的题目](https://labuladong.gitee.io/algo/1/12/)

- 最小滑窗

[学习链接](https://leetcode-cn.com/problems/fruit-into-baskets/solution/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr/)

[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```js
// 最小滑窗的更新思路
var minSubArrayLen = function (target, nums) {
  // 长度最小的子数组
  let min = Number.MAX_SAFE_INTEGER;
  // i 指向当前最小连续子数组的开始下标
  // j 指向当前最小连续子数组的结束下标的后一位
  let i = 0,
    j = 0,
    sum = 0;
  while (j <= nums.length) {
    while (sum >= target) {
      // 满足条件不断压缩
      min = Math.min(j - i, min); // 在满足条件的情况下不断更新
      sum -= nums[i++];
    }
    sum += nums[j++];
  }
  return min === Number.MAX_SAFE_INTEGER ? 0 : min;
};
```

[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```js
var minWindow = function (s, t) {
  // 滑动窗口相关思路(最小滑窗)
  const map = new Map();
  for (const item of t) {
    map.set(item, map.get(item) + 1 || 1);
  }

  const sMap = new Map();
  let i = 0,
    j = 0,
    chars = new Set(), // 字母已经匹配完成
    strs = "",
    len = Number.MAX_SAFE_INTEGER;

  for (; j < s.length; j++) {
    sMap.set(s[j], sMap.get(s[j]) + 1 || 1);
    if (sMap.get(s[j]) >= map.get(s[j])) {
      chars.add(s[j]);
    }
    while (chars.size === map.size) {
      // 不断压缩窗口直到不满足条件
      // 更新对应的值
      const currentStrs = s.slice(i, j + 1);
      if (currentStrs.length < len) {
        strs = currentStrs;
        len = currentStrs.length;
      }

      sMap.set(s[i], sMap.get(s[i]) - 1);
      if (sMap.get(s[i]) < map.get(s[i])) {
        // 说明此时已经不是最小滑窗了
        chars.delete(s[i]);
      }
      i++;
    }
  }
  return strs;
};
```

同类型的题目 [剑指 Offer II 017. 含有所有字符的最短字符串](https://leetcode.cn/problems/M1oyTv/)

- 最大滑窗

[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```js
// 最大滑窗口的更新思路
var totalFruit = function (fruits) {
  if (fruits.length <= 2) {
    return fruits.length;
  }
  // 只有两个篮子
  let i = 0,
    j = 0,
    max = Number.MIN_SAFE_INTEGER;
  const map = new Map();
  // i 指向当前最大滑窗的开始位置
  // j 指向当前最大滑窗的结束位置
  while (j < fruits.length) {
    map.set(fruits[j], map.get(fruits[j]) + 1 || 1);
    while (map.size >= 3) {
      // 不满足条件才去缩小左边界
      let current = fruits[i];
      map.set(current, map.get(current) - 1);
      if (map.get(current) === 0) {
        map.delete(current);
      }
      i++;
    }
    max = Math.max(max, j - i + 1);
    j++;
  }
  return max;
};
```

[剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

```js
var lengthOfLongestSubstring = function (s) {
  // 最大滑窗(最长不包含重复字符)
  const set = new Set(s);

  const dMap = new Map(); // 用于中间计算过程
  let i = 0,
    j = 0,
    count = Number.MIN_SAFE_INTEGER;
  for (; j < s.length; j++) {
    if (set.has(s[j])) {
      dMap.set(s[j], dMap.get(s[j]) + 1 || 1);
    }
    while (dMap.get(s[j]) > 1) {
      // 不满足条件啦要缩小窗口啦
      dMap.set(s[i], dMap.get(s[i]) - 1);
      i++;
    }
    count = Math.max(count, j - i + 1);
  }
  return count === Number.MIN_SAFE_INTEGER ? 0 : count;
};
```

### 螺旋矩阵

螺旋矩阵的意思是按照一定的顺序填充数组元素，里面并不涉及特别多的算法，难的在于对边界条件的判断，在写的过程中我们遵循一定的规则，即无论是填充行还是填充列，都必须保证 [ ) 左闭右开的区间范围这样才不容易出错。

[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

## 八、专题之双指针

> 双指针的用途非常广泛，可以用来解决数组的问题、链表的问题，链表的问题多为使用快慢指针（求倒数第 k 个节点、是否有环等等），具体在链表的环节也有说明，下面就说说针对数组而言的双指针。

### 快慢指针

- 快指针什么时候移动？

- 慢指针什么时候移动？
- 快慢指针移动步数时候有联系？

1. [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)(原地移除) -- 非常经典的问题
2. [485. 最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

```js
var removeElement = function (nums, val) {
  let len = nums.length;

  let slow = 0,
    fast = 0;
  while (fast < len) {
    if (nums[fast] !== val) {
      nums[slow] = nums[fast];
      slow++;
    }
    fast++;
  }

  return slow;
};
```

3. [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```js
var minSubArrayLen = function (target, nums) {
  let n = nums.length;
  if (n == 0) {
    return 0;
  }
  let ans = Number.MAX_SAFE_INTEGER;
  let sum = 0;
  let i = 0,
    j = 0;
  while (j < n) {
    sum += nums[j];
    while (sum >= target) {
      // 缩小区间的过程
      ans = Math.min(ans, j - i + 1);
      sum -= nums[i];
      i++;
    }
    j++;
  }
  // 肯定存在最后不满足的情况
  return ans === Number.MAX_SAFE_INTEGER ? 0 : ans;
};
```

有序列表去重

> 在开辟额外数组空间的基础上在原数组进行数据替换，最后保留不重复数字个数的数组（当然这是基于有序数组，不然肯定得借助一个哈希表什么的来记录）

```js
var removeDuplicates = function (nums) {
  if (nums.length <= 1) {
    return nums;
  }

  // 使用快慢指针的方式
  let slow = 0,
    fast = 0;
  while (fast < nums.length) {
    if (nums[slow] !== nums[fast]) {
      // 这样的顺序设置是因为第一位永远保留
      ++slow;
      nums[slow] = nums[fast];
    }
    fast++;
  }

  // slow 维护的是最大不重复序列的序列号（区别于长度）
  return slow + 1;
};
```

元素移除 | 移动零

> 删除数组中等于 val 的元素，最后改变数组的长度进行输出

```js
var removeElement = function (nums, val) {
  let len = nums.length;

  let slow = 0,
    fast = 0;
  while (fast < len) {
    if (nums[fast] !== val) {
      // 区别于上面的顺序
      nums[slow] = nums[fast];
      slow++;
    }
    fast++;
  }

  // slow 维护的是最长不等于val的序列长度
  // 借助 nums =[3 2 2 3] val=3 来理解
  return slow;
};
```

> 移动零是在上面的基础上将 val 变成 0，只是说最后的数组长度不变化，将后面所有的元素全部变为 0

### 首尾指针（左右指针）

> 指针运动方向相反，又叫左右指针

1. 二分查找（经典问题）

2. 两数之和

[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

[561. 数组拆分 I](https://leetcode-cn.com/problems/array-partition-i/)

1. [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

### 中心扩散

1. \*最长回文子串

> 要找出最长回文子串的意思是该字符串的子串存在多个回文子串，要我们找出长度最长的那一个子串。这道题的解法并不想之前的首尾指针或者快慢指针，使用的是中心扩散的方式，中心扩散的意思是两指针从中间向两边扩散。

```js
var longestPalindrome = function (s) {
  const findStr = (s, left, right) => {
    // 防止越界 & 条件符合判断
    while (
      left >= 0 &&
      right < s.length &&
      s.charAt(left) === s.charAt(right)
    ) {
      left--; // 向左扩散
      right++; // 向右扩散
    }
    // 可以根据例子babad left=2, right=2 去理解为什么要这样返回
    return s.slice(left + 1, right);
  };

  let res = ""; // 一定要赋值为空串不然没有 length 属性
  for (let i = 0; i < s.length; i++) {
    const s1 = findStr(s, i, i); // 寻找奇数长度的回文串
    const s2 = findStr(s, i, i + 1); // 寻找偶数长度的回文串
    res = res.length > s1.length ? res : s1;
    res = res.length > s2.length ? res : s2;
  }

  return res;
};
```

### NSUM 问题

> 很常见的一个问题，比如说找满足 num1 + num2 = val 的二元组，num1 + num2 + num3 = val 的三元组，或者找满足 num1 + num2 + num3 + num4 = val 的四元组。二元组的问题可以通过排序后使用左右指针简单解决（哈希表），但是到三元甚至四元的时候就会感觉整个过程有点混乱了。

1. 两数之和（哈希表）

> 使用哈希表是基于当前给定的数组是无序的，如果需要排序后再进行查找的话可能需要最小的时间复杂度都要 O(nlogn)，哈希表的查询时间为 O(1)，总的来计算时间复杂度是 O(n)，所以考虑用空间换时间

```js
var twoSum = function (nums, target) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    map.set(nums[i], i);
  }

  for (let i = 0; i < nums.length; i++) {
    let cal = target - nums[i]; // 查找是否存在一个cal满足 cal + num[i] = target
    let index = map.get(cal);
    // 存在且不等于自身
    if (index && index !== i) {
      return [i, index];
    }
  }
  return [-1, -1];
};
```

> 在上面的基础上如果拓展到三数之和，四数之和，甚至五数之和，其实是可以抽取一套 n 数之和的模版来解决这一样的问题。

对于三数之和的具体思路：

1. 确定第一个数，剩下 target - num[i]
2. 套用两数之和的模版来匹配
3. 在保证 1 步骤元素不重复的基础上，循环 1 & 2 操作
4. 输出最后结果

对了四数之和的基本思路：

1. 确定第一个数，剩下 target - num[i]
2. 套用三数之和的模版来匹配
3. 在保证 1 步骤元素不重复的基础上，循环 1 & 2 操作
4. 输出最后结果

对于 n 数之和的基本思路:

1. 确定第一个数，剩下 target - num[i]
2. 套用 (n-1) 数之和的模版来匹配
3. 在保证 1 步骤元素不重复的基础上，循环 1 & 2 操作
4. 输出最后结果

```js
/**
 * @function 返回满足n数之和的序列
 * @param {*} list 原序列
 * @param {*} n  n的个数
 * @param {*} start 从哪个下标开始匹配
 * @param {*} target 目标数
 */
const NSum = function (list, n, start, target) {
  const size = list.length;

  const res = [];
  // 必须满足list长度大于n 和至少是两数之和
  if (size < n || n < 2) {
    return res;
  }

  if (n == 2) {
    // 套用 两数之和的模版
    let low = start,
      high = size - 1;
    while (low < high) {
      let sum = list[low] + list[high];
      let lowItem = list[low],
        highItem = list[high];
      if (sum < target) {
        // 左指针右移
        while (low < high && list[low] === lowItem) {
          low++;
        } // 去重影响
      } else if (sum > target) {
        // 右指针左移
        while (low < high && list[high] === highItem) {
          high--;
        } // 去重影响
      } else {
        // 相等
        res.push([list[low], list[high]]);
        while (low < high && list[low] === lowItem) {
          low++;
        }
        while (low < high && list[high] === highItem) {
          high--;
        }
      }
    }
  } else {
    // 递归求n(n>=3) sum 之和
    for (let i = start; i < size; i++) {
      if (i == 0 || list[i] !== list[i - 1]) {
        // 去重影响
        let arr = NSum(list, n - 1, i + 1, target - list[i]);
        arr = arr.map((item) => {
          let tmp = [list[i]].concat(item);
          res.push(tmp);
          return tmp;
        });
      }
    }
  }
  return res;
};
```

### 滑动窗口

> 滑动窗口基本的思想是通过左右指针之间的窗口维护当前符合情况的列表子串，本质上其实还是使用双指针，但是在处理窗口移动的时候的各种边界情况需要特别注意

tips

- 当移动 right 扩大窗口加入字符时，应该更新哪些数据
- 什么条件下，窗口应该暂停扩，开始移动 left 缩小窗口
- 当移动 left 缩小窗口移出字符时，应该更新哪些数据
- 我们要的结果应该在扩大窗口时还是缩小窗口时更新

```js
// 滑动窗口模版
function huadong(s, t) {
  const need = new Map(), window = new Map()
  for(let item of t) {
    need.set(item, need.has(item) ? need.get(item) + 1 : 1)
  }

  let left = 0, right = 0 // 滑动的左右指针
  let valid = 0   // window 满足 need 条件的字符数量

  while(right < s.length) {
    // 移入窗口的字符
    let c = s[right]
    right++
    // 进行窗口内数据的一系列更新
    ...

    // 判断左窗口是否需要收缩
    while(...) {
      let d = s[left] // 需要移出的字符
      // 左移窗口
      left++
      // 进行窗口内数据的一系列更新
      ...
  }
}

```

上面代码中需要注意的问题

> 1. 窗口的区间是[left, right)，是左闭右开的，所以放入窗口之后 right 要++，举个例子一开始的时候是 [0, 0), 放入一个元素是[0, 1)，right - left 就是当前窗口中子串的长度
> 2. 一定要想清楚收缩的时机，有可能是 valid === need.size 时候收缩（求最小覆盖子串），也有可能是 right - left >= t.length 的时候收缩（求子串排列），根据不同的场合定义不同的收缩策略

练习题

> [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)  
> [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

```js
var minWindow = function (s, t) {
  const need = new Map(),
    window = new Map();
  for (let item of t) {
    need.set(item, need.get(item) ? need.get(item) + 1 : 1);
  }

  let left = 0,
    right = 0; // 滑动的左右指针
  let valid = 0; // window 满足 need 条件的字符数量

  // 记录最小覆盖子串的起始索引及长度
  let start = 0,
    len = Number.MAX_SAFE_INTEGER;

  while (right < s.length) {
    // 移入窗口的字符
    let c = s[right];
    right++;
    // 进行窗口内数据的一系列更新
    if (need.get(c)) {
      window.set(c, window.get(c) ? window.get(c) + 1 : 1);
      if (need.get(c) === window.get(c)) {
        valid++; // 更新满足字符个数
      }
    }

    while (valid === need.size) {
      // 更新最小覆盖子串
      if (right - left < len) {
        start = left;
        len = right - left;
      }

      let d = s[left]; // 需要移出的字符
      // 左移窗口
      left++;
      // 进行窗口内数据的一系列更新
      if (need.get(d)) {
        if (window.get(d) === need.get(d)) {
          // 刚好达到临界条件的时候才去更新
          valid--;
        }
        window.set(d, window.get(d) - 1);
      }
    }
  }

  return len == Number.MAX_SAFE_INTEGER ? "" : s.slice(start, start + len);
};
```

### 总结

总的来说，双指针模块比较常见的三总方法就是上面列出的一些方法，无论是哪一种方法，关键的还是指针移动时机的问题。滑动窗口也是双指针的一种，对应于需要累加的滑动窗口，如上 209 题所示就是对应的解题模版，如果是涉及到字符串的滑动窗口，则需要建立对应的哈希表来存储字符。双指针常出现在数组和字符串的题目中。

需要注意的问题：

1. 指针移动方向
2. 指针移动的条件
3. 结果对应的临界

## 九、专题之哈希表

:key: 当我们需要降低元素查找的时间复杂度的话可以使用哈希表去优化。普通的查找是通过循环的方式去进行，而哈希表对于查找而言具有线性的时间复杂度。

:exclamation: 一般来说哈希表都是用来快速判断一个元素是否出现在集合中

常用的三种哈希表

- 数组 -- 通常用于数组大小是受限的情况
- set 结构 -- 输出结果是唯一的情况
- map 结构 --

[学习链接](https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93.html#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8)

## 十、专题之链表

[学习链接](https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8D%95%E9%93%BE%E8%A1%A8)

> 链表里面用到最多的可能就是双指针，或者是辅助栈等等。

1、合并两个有序链表

> https://leetcode-cn.com/problems/merge-two-sorted-lists/

- 原理其实和归并排序是一样的，时间复杂度是 O(m+n)，通过遍历两个指针在链表上的移动把较小或者较大的节点放到新的链表上。需要注意的是，这里其实是需要建立一个虚拟头结点来简化头结点和非头结点的不同处理

```js
let l3 = tmp = new ListNode(0)
while(l1 && l2) {
    tmp = new ListNode(0)
    tmp = tmp.next
    // 判断赋值
    tmp.value = .....
}

// 有余的话直接整串拿走
l1 && l3.next = l1
l2 && l3.next = l2

return l3.next
```

2、合并 k 个有序链表(困难题就先不考虑了)

3、寻找单链表的倒数第 k 个节点

> https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/

- 可以使用快慢指针的思路，快指针比慢指针领先 k 个节点，但快指针到达尾部的时候，慢指针和快指针之间节点的差异就是 k 个，那么就满足题目的要求了。

```js
let fast = head,
  low = new ListNode(0);
low.next = head;

while (k) {
  // 先让快指针走 k 步
  fast = fast.next;
  k--;
}
while (fast) {
  // 慢指针和快指针同时走
  fast = fast.next;
  low = low.next;
}

// 最后慢指针指向的是当前倒数第 K 个节点的前缀节点
// 这也是为什么需要定义 low 初始指向虚拟头结点的原因
return low.next;
```

4、寻找单链表的中点

> https://leetcode-cn.com/problems/middle-of-the-linked-list/

- 其实也是使用快慢指针，只不过每次快指针向前走两步，慢指针向前走一步，这样慢指针最后指向的就是想要的中间节点。代码中需要注意的是处理偶数长度序列和奇数长度序列的情况

```js
let low = head,
  fast = head;
while (fast && fast.next) {
  // 画个图就很清晰了
  low = low.next;
  fast = fast.next.next;
}

return low;
```

5、判断单链表是否包含环并找出环起点

- 其实本质上是一个追及问题，我们在这里并不关心什么时候在哪个节点会相遇，关注的是到底是否能相遇，同样是使用快慢指针的方法，具体的描述其实和上面是一样的（快 2 慢 1）

```js
let fast = head,
  low = head;
while (fast && fast.next) {
  low = low.next;
  fast = fast.next.next;
  if (low === fast) {
    // 代表能够追上就是有回环
    return true;
  }
}
return false;
```

- 在上面判断是否有环的基础上还要新增一个要求就是能够找出对应的环开始的起点，这可能就涉及到数学上相遇问题的计算了，反正最后的解决方案就是通过将某个指针移动到 head 节点，然后两个指针同步前进，最后相遇的点就是环的起点。

```js
let fast = head,
  low = head;
while (fast && fast.next) {
  low = low.next;
  fast = fast.next.next;
  if (low === fast) {
    // 代表能够追上就是有回环
    break;
  }
}
if (!fast || !fast.next) {
  // 没有环
  return null;
}

fast = head;
while (slow != fast) {
  fast = fast.next;
  low = low.next;
}

return low;
```

6、判断两个单链表是否相交并找出交点

> 1. 正常的做法是使用 Set 结构存储一个链表的所有节点，在遍历另一个链表的时候判断是否有相同的节点。但是这样可能就会带来 O(n) 的空间复杂度。
> 2. 第二种做法是通过双指针的方式，具体可以参考 https://labuladong.gitee.io/algo/2/18/17/

```js
let p1 = head1, p2 = head2
while (p1 != p2) {
        // p1 走一步，如果走到 A 链表末尾，转到 B 链表
        if (p1 == null) p1 = headB;
        else  p1 = p1.next;
        // p2 走一步，如果走到 B 链表末尾，转到 A 链表
        if (p2 == null) p2 = headA;
        els p2 = p2.next;
    }
return p1;

```

链表是通过指针串联起来的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null。

- 单链表

![链表1](https://img-blog.csdnimg.cn/20200806194529815.png)

- 双向链表

![链表2](https://img-blog.csdnimg.cn/20200806194559317.png)

- 循环链表

![链表4](https://img-blog.csdnimg.cn/20200806194629603.png)

[203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

```js
var removeElements = function (head, val) {
  // 遍历 -- 过程删除 val
  let t = (pre = new ListNode(0, head));
  while (t && t.next) {
    if (t.next.val === val) {
      let next = t.next.next;
      t.next = next;
      continue; // 易错点 -- 如果相等意味着删除节点后不需要进行平移 t 的操作
    }
    t = t.next;
  }
  return pre.next;
};
```

上面这段代码是很久之前写的，感觉看上去会有点绕或者一下子可能会看不明白。首先从如何构建一个链表开始(虽然力扣不需要自行构建但是其实构建的过程还是值得思考的！)

```js
// 链表类
class ListNode {
  val;
  next = null;
  constructor(val, next) {
    this.val = val || 0;
    this.next = next || null;
  }
}

function constructList(list = []) {
  // list 给定的是 val 数组
  const root = new ListNode(0);
  let t = root;
  for (const item of list) {
    const next = new ListNode(item);
    t.next = next;
    t = t.next;
  }
  return root.next;
}
```

```js
function deleteListNode(head, val) {
  head = constructList(head);
  const prev = new ListNode(0, head);
  // t 始终指向的是当前 head 的前缀节点
  let t = prev;
  while (head) {
    if (head.val === val) {
      // 删除节点
      t.next = head.next;
    } else {
      t = t.next;
    }
    head = head.next;
  }
  return prev.next;
}
```

:key: 这样我们并不需要考虑删除废弃节点的情况，因为 JS 内部有 v8 垃圾回收机制进行定时清除，而且 JS 里面链表的结构和 C 或者 C++ 的不太一样，每个指针其实都指向一整个链表而不是单纯代表一个节点，所以对一个节点进行 set null 操作整个链表的结构就会

[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

:key: 需要明确每次保存的节点，每次开始的节点也就是下面的 next ，可以理解为 next 是下次开始的节点 。拿 1->2->3->4->5 举例，依次是 1 2 3 4 5

```js
var reverseList = function (head) {
  if (!head || !head.next) {
    return head;
  }

  let prev = null;
  while (head) {
    const next = head.next; // 保存 next 指向
    head.next = prev; // 更新当前 head 的指向
    prev = head;
    head = next;
  }

  return prev;
};
```

[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

:key: 明确交换的步骤，每一次一共有三步，三步怎么操作可以通过画图去理解。

```js
var swapPairs = function (head) {
  if (!head || !head.next) {
    return head;
  }
  const prev = new ListNode(0, head);
  let t = prev;
  while (t.next && t.next.next) {
    // 画图明确操作其实就不会很难
    const next = t.next.next,
      prev = t.next;
    prev.next = next.next;
    next.next = prev;
    t.next = next;
    t = prev;
  }
  return prev.next;
};
```

[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

:key: 初始条件即 slow 和 fast 的选择尤为重要，选择最容易记住的那种即可！！！

```js
var removeNthFromEnd = function (head, n) {
  // 难点在于选取初始节点
  // slow 初始必须置为虚拟节点，因为考虑到删除的是第一个节点
  // fast 可以正常从 head 开始向右移动
  let prev = new ListNode(0, head);
  let slow = (fast = prev);
  // let slow = prev, fast = head // 对应下面就得改成 while(fast) {}

  while (n) {
    fast = fast.next;
    n--;
  }

  while (fast.next) {
    slow = slow.next;
    fast = fast.next;
  }

  slow.next = slow.next.next;
  return prev.next;
};
```

[面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

```js
var getIntersectionNode = function (headA, headB) {
  // 基本的思路就是先走完 A 用哈希表记录下对应的索引指针，在 B 走的时候判断节点是否出现在哈希表中
  let set = new Set();
  while (headA) {
    set.add(headA);
    headA = headA.next;
  }

  while (headB) {
    if (set.has(headB)) {
      return headB;
    }
    headB = headB.next;
  }
  return null;

  // 进阶的设计：能不能不使用空间复杂度呢？
  // head1 走完 A从 B 走， head2 走完 B从A 走
  // 不需要担心死循环，不想交的话两者
  if (!headA || !headB) {
    return null;
  }
  let head1 = headA,
    head2 = headB;
  while (head1 !== head2) {
    head1 = head1 ? head1.next : headB;
    head2 = head2 ? head2.next : headA;
  }

  return head1;
};
```

[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

:key: 判断是否有环不难，但是如何找到入环点就要响应的数学原理的证明：为什么一定是 slow 从 head 出发，然后 fast 从环中相遇节点出发最后两者会在入环节点相遇？？？其实我们可以记住这样一个特例。

<img src="E:\杂七杂八的东西\typeorm 图片存储区\image-20220501171440443.png" alt="image-20220501171440443" style="zoom:60%;" />

x == y == z 这样一个特殊情况，fast 每次比 slow 快两步

```js
var detectCycle = function (head) {
  /*
        1. 是否有环
        2. 如何找到入环点
    */
  if (!head || !head.next) {
    return null;
  }
  let slow = head.next,
    fast = head.next.next;
  while (fast && fast.next && fast !== slow) {
    // 判断是否存在环
    slow = slow.next;
    fast = fast.next.next;
  }
  if (!fast || !fast.next) {
    return null;
  }

  // slow 从头结点开始, fast 从相遇节点开始 -- 相遇节点就是入环点
  slow = head;
  while (slow !== fast) {
    slow = slow.next;
    fast = fast.next;
  }
  return slow;
};
```

[707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)

:star: 这是一道综合性非常强的题目，总得来说里面的细节还是挺多的，添加头结点的时候原来是不是空的呀，删除完以后链表是否为空啊等等！！！

```js
function ListNode(val, next) {
  this.val = val || 0;
  this.next = next || null;
}

var MyLinkedList = function () {
  this._size = 0; // 当前链表的长度
  this._head = null; // 头结点
  this._tail = null; // 尾结点
};

/* 通用获取第 index 个节点的方法 */
MyLinkedList.prototype.getNode = function (index) {
  if (index < 0 || index >= this._size) {
    return null;
  }
  let node = new ListNode(0, this._head);
  while (index) {
    node = node.next;
    index--;
  }
  return node.next;
};

/* 获得第 index 个节点 */
MyLinkedList.prototype.get = function (index) {
  if (index < 0 || index >= this._size) {
    return -1;
  }
  return this.getNode(index).val;
};

/* 头部插入节点 */
MyLinkedList.prototype.addAtHead = function (val) {
  const node = new ListNode(val, this._head);
  this._head = node;
  this._size++; // 节点累加
  if (!this._tail) {
    // 初始 head == tail == null 时
    this._tail = node;
  }
};

/* 尾部插入节点 */
MyLinkedList.prototype.addAtTail = function (val) {
  const node = new ListNode(val, null);
  this._size++;
  if (this._tail) {
    // tail 存在
    this._tail.next = node;
    this._tail = node;
    return;
  }
  // 刚开始 tail === head === null
  this._tail = node;
  this._head = node;
};

/* 在指定索引后面添加节点 */
MyLinkedList.prototype.addAtIndex = function (index, val) {
  if (index > this._size) {
    return;
  }
  if (index <= 0) {
    this.addAtHead(val); // 内部会进行累加
    return;
  }
  if (index === this._size) {
    this.addAtTail(val); // 内部会进行累加
    return;
  }

  let node = this.getNode(index - 1); // 获得目标节点的前缀节点
  node.next = new ListNode(val, node.next);
  this._size++;
};

/* 删除某个索引的节点 */
MyLinkedList.prototype.deleteAtIndex = function (index) {
  if (index < 0 || index >= this._size) {
    return;
  }
  if (index === 0) {
    // 删除头结点
    this._head = this._head.next;
    if (index === this._size - 1) {
      // 同时是尾节点
      this._tail = this._head;
    }
    this._size--;
    return;
  }
  const node = this.getNode(index - 1);
  node.next = node.next.next;
  if (index === this._size - 1) {
    // 删除的是尾结点
    this._tail = node;
  }
  this._size--;
};
```

## 十一、专题之二叉树

- 二叉树的最大深度

```js
// 深度优先搜索
var maxDepth = function (root) {
  if (root == null) {
    return 0;
  }
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};

// 广度优先搜索
var maxDepth = function (root) {
  if (root == null) {
    return 0;
  }

  const queue = [root];
  let depth = 0;

  while (queue.length > 0) {
    const size = queue.length;
    for (let i = 0; i < size; i++) {
      const item = queue.shift();
      item.left && queue.push(item.left);
      item.right && queue.push(item.right);
    }
    depth++;
  }

  return depth;
};
```

- 二叉树的遍历模版

```js
traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}
```

### 二叉树之前缀树

> Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作

从概念来说，二叉树的种类有满二叉树、完全二叉树、二叉搜索树、平衡二叉搜索树，对应的每一个种类都有对应的用途，怎么建立一棵树也是一个非常有考究的问题。

### 二叉树遍历

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```js
var preorderTraversal = function (root) {
  // 递归解法
  const r = [];
  const search = (root) => {
    if (root == null) {
      return [];
    }
    r.push(root.val);
    root.left && search(root.left);
    root.right && search(root.right);
  };
  search(root);
  return r;

  // 迭代的解法
  if (root == null) {
    return [];
  }
  const stack = [root],
    rt = [];
  while (stack.length) {
    const node = stack.pop();
    rt.push(node.val);
    node.right && stack.push(node.right);
    node.left && stack.push(node.left);
  }
  return rt;
};
```

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```js
var inorderTraversal = function (root) {
  // 递归解法
  const rt = [];
  const search = (root) => {
    if (root == null) {
      return;
    }
    root.left && search(root.left);
    rt.push(root.val);
    root.right && search(root.right);
  };
  search(root);
  return rt;

  // 迭代解法
  const rt = [],
    stack = [];
  while (root || stack.length) {
    // 防止出现初始root左子树为空，stack长度为0的情况
    while (root) {
      stack.push(root);
      root = root.left;
    }
    const node = stack.pop();
    rt.push(node.val);
    root = node.right;
  }

  return rt;
};
```

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

:star: 迭代解法其实就是将 中-右-左的顺序返回结果进行逆序输出

```js
var postorderTraversal = function (root) {
  // 递归解法
  const rt = [];
  const search = (root) => {
    if (root == null) {
      return;
    }
    root.left && search(root.left);
    root.right && search(root.right);
    rt.push(root.val);
  };
  search(root);
  return rt;

  // 迭代解法
  if (root == null) {
    return [];
  }
  const stack = [root],
    rt = [];
  while (stack.length) {
    const node = stack.pop();
    rt.push(node.val);
    node.left && stack.push(node.left);
    node.right && stack.push(node.right);
  }
  return rt.reverse();
};
```

:exclamation: 上面迭代的后序遍历算法其实是一种取巧的方法，只能帮我们获得最终的顺序，访问的过程和后续没有多大关系，假如后续的过程中需要进行某些处理实际上是做不到的。

对于后序遍历的迭代，其实下面才是正确的解法

```js
// 后序
var postorderTraversal = function (root) {
  // 通过一个 prev 的历史栈来判断当前节点的右节点是否访问完成
  const rt = [];
  let prev = null;
  const dfs = (root) => {
    const stack = [];
    while (root || stack.length) {
      while (root) {
        // 遍历到左叶子
        stack.push(root);
        root = root.left;
      }
      const node = stack.pop();
      if (node.right == null || prev == node.right) {
        // 判断有没有右子树或者说右子树是否访问过
        // 放入中间节点
        rt.push(node.val);
        prev = node;
      } else {
        // 继续往右子树遍历
        stack.push(node);
        root = node.right;
      }
    }
  };

  dfs(root);
  return rt;
};
```

### 二插树递归函数

1. 确定递归函数的参数和返回类型

   其中怎么知道递归函数什么时候需要返回值，需要什么样的返回值，总结如下：

   - 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值(113. 路径总和 II)
   - 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值
   - 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回(不继续下去了)。(112. 路径总和)

2. 确定终止条件

3. 确定单层递归

:key: 一般一起操作两个二叉树都是使用队列模拟类似层次遍历，同时处理两个树的节点。

### 二叉搜索树

#### 二叉搜索树的性质

1. 根节点的值比左子树的所有节点的值都要大
2. 根节点的值比右子树的所有节点的值都要小
3. 左子树和右子树都满足上面的性质

> 二叉搜索树验证

1、对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。  
2、对于 BST 的每一个节点 node，它的左侧子树和右侧子树都是 BST。

> 因此对 BST 的中序遍历可以得到一系列升序的数组值。直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的

- 所以一般在遇到二叉搜索树的时候，基本的解决是利用二叉搜索树左节点 < 根节点 < 右节点的性质来实现计数排名，利用中序遍历的方式来解决问题。

1. 二叉搜索树中第 k 小的元素

> https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/

```js
/**
 * 利用二叉搜索树 右 > 中 > 左 的性质
 */
var kthSmallest = function (root, k) {
  const res = [];
  const search = (root) => {
    if (root == null) {
      return;
    }
    // 前序
    search(root.left);
    // 中序
    res.push(root.val);
    // 后序
    search(root.right);
  };

  search(root);
  return res[k - 1];
};
```

2. 把二叉搜索树转换为累加树

> https://leetcode-cn.com/problems/convert-bst-to-greater-tree/

```js
var convertBST = function (root) {
  let sum = 0;
  const search = (root) => {
    if (root == null) {
      return;
    }

    // 前序
    search(root.right);
    // 中序
    sum += root.val;
    root.val = sum;
    // 后续
    search(root.left);
  };

  search(root);

  return root;
};
```

> 上面这道题目很巧妙地使用 右 -> 中 -> 左的遍历顺序来实现对 sum 的累加

3. 二叉树的序列化和反序列化

> 二叉树的序列化和反序列化其实就是把一棵树转换为字符串或者把一个字符串转换为树的过程，这里能转换的基础是因为能知道对应的空节点位置，不然的话得根据先序遍历+中序遍历或者中序遍历+后序遍历来找到对应的根节点再根据左子树和右子树来建树。

既然说到了通过先序遍历和后序遍历来建树，那就以一道实际的题目作为例子  
[105 从前序与中序遍历构建二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

<img src="https://img-blog.csdnimg.cn/20200812191501419.png" alt="二叉搜索树" style="zoom:67%;" />

1. 不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。（上图就是一个例子）
2. 在一个有序序列求最值的时候，不要定义一个全局变量，然后遍历序列更新全局变量求最值。因为最值可能就是 int 或者 longlong 的最小值(那么就永远不会导致全局变量的更新)，推荐要通过前一个数值（pre）和后一个数值比较（cur），得出最值。

[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

```js
var sortedArrayToBST = function (nums) {
  /* 高度平衡意味着要取 nums 的中间节点作为根节点 */
  /* 坚持区间的闭合原则 */
  /* var traversal = (arr, left, right) => {
        if(left > right) { return null }
        let mid = Math.floor((left + right) / 2)
        const root = new TreeNode(arr[mid])
        root.left = traversal(arr, left, mid - 1)
        root.right =  traversal(arr, mid + 1, right) 
        return root
    }
    return traversal(nums, 0, nums.length - 1) */

  /* 迭代的解法 */
  var traversal = (arr, left, right) => {
    const root = new TreeNode();
    const leftStack = [left],
      rightStack = [right],
      stack = [root];
    while (stack.length) {
      let left = leftStack.pop(),
        right = rightStack.pop(),
        node = stack.pop();
      let mid = left + Math.floor((right - left) / 2);
      node.val = arr[mid];

      // 处理左区间
      if (left <= mid - 1) {
        node.left = new TreeNode(0);
        stack.push(node.left);
        leftStack.push(left);
        rightStack.push(mid - 1);
      }

      // 处理右区间
      if (right >= mid + 1) {
        node.right = new TreeNode(0);
        stack.push(node.right);
        leftStack.push(mid + 1);
        rightStack.push(right);
      }
    }
    return root;
  };
  return traversal(nums, 0, nums.length - 1);
};
```

#### 二叉树之最小公共祖先

1. 需要从底向上遍历，使用后序遍历(回溯)的方法
2. 在回溯的过程中，必须要遍历整颗二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值
3. 要理解如果返回值 left 为空，right 不为空为什么要返回 right，为什么可以用返回 right 传给上一层结果

<img src="E:\杂七杂八的东西\typeorm 图片存储区\20210204151125844.png" alt="236.二叉树的最近公共祖先1" style="zoom:50%;" />

:star: 如何区分递归函数有返回值的时候是搜索一条边还是搜索一整棵树

```js
// 搜索一条边
if (递归函数(root->left)) return ;
if (递归函数(root->right)) return ;
```

```js
// 搜索一整棵树
left = 递归函数(root->left);
right = 递归函数(root->right);
left与right的逻辑处理;
```

- 在二叉搜索树中找最近的祖先元素(找到了就结束了)

#### 二叉搜索树 插入

(时刻提醒自己遇到二叉搜索树一定就不要把整棵树都去遍历一遍了，一定要分情况地左右去遍历)

所以插入也是类似的，插入的时机是在遍历到空节点的时候，分左右的情况去插入。

```js
const traversal = (root, val) => {
  if (root == null) {
    return new TreeNode(val);
  }
  if (root.val > val) {
    root.left = traversal(root.left, val);
  }
  if (root.val < val) {
    root.right = traversal(root.right, val);
  }
  return root;
};
```

​

## 十二、专题之回溯算法

回溯算法的关键在于思考三个问题

- 路径：已经做出的选择
- 选择列表：当前可以做出的选择
- 结束条件：到达决策树底层，无法再做选择条件

```python
# 回溯算法的框架
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

回溯的关键在于弄清楚什么是选择.

### 简单回溯

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

伪代码分析

```js
function backtrack(nums, i) {
    if(i === nums.length) {
        if 达到 target
        	result += 1
    }

    for op in {-1, +1} {
		选择op * nums[i]
        // 穷举nums[i+1]所有的选择
        backtrack(nums, i+1)
        撤销选择
    }
}
```

```js
var findTargetSumWays = function (nums, target) {
  if (nums.length == 0) return 0;
  let result = 0;

  const backtrack = (nums, i, remain) => {
    if (i === nums.length) {
      if (remain === 0)
        //
        result += 1;
      return;
    }

    // 下面是基于如何把 remain 减到 0 的过程
    // - 的时候进行 +
    // + 的时候进行 -

    // 选择 - 号
    remain += nums[i];
    backtrack(nums, i + 1, remain);
    remain -= nums[i];

    // 选择 + 号
    remain -= nums[i];
    backtrack(nums, i + 1, remain);
    remain += nums[i];
  };

  backtrack(nums, 0, target);
  return result;
};
```

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```js
const res = [];
var permute = function (nums) {
  const path = []; // 路径
  backtrack(nums, path); // 进入回溯
  return res;
};

var backtrack = function (nums, path) {
  // 满足条件
  if (path.length >= nums.length) {
    res.push(path.slice(0)); // 添加路径
    return; // 结束当前层的递归过程
  }

  for (let i = 0; i < nums.length; i++) {
    if (path.indexOf(nums[i]) === -1) {
      // 限定约束条件
      // 做选择
      path.push(nums[i]);
      backtrack(nums, path);
      // 撤销选择
      path.pop();
    }
  }
};
```

对于全排列问题选择的是列表中的元素，所以我们可以写出下面的伪代码：

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

```js
var combine = function (n, k) {
  const res = []; // 结果
  const path = []; // 路径
  const backtrack = (_n) => {
    if (path.length >= k) {
      // 递归结束条件
      res.push(path.slice(0));
      return;
    }

    // i - n 代表元素选择的个数
    for (let i = _n; i <= n - (k - path.length) + 1; i++) {
      // 存在冗余的分支判断，比如说从 4开始选择两个 后面压根就没得选了
      path.push(i);
      backtrack(i + 1);
      path.pop();
    }
  };

  backtrack(1);
  return res;
};
```

[代码随想录 -- 回溯算法的讲解](https://www.programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF)

回溯算法可以解决的问题：

- 组合问题：N 个数里面按一定规则找出 k 个数的集合
- 排列问题：N 个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个 N 个数的集合里有多少符合条件的子集
- 棋盘问题：N 皇后，解数独等等

<img src="https://img-blog.csdnimg.cn/20210219192050666.png" alt="回溯算法大纲" style="zoom: 33%;" />

```js
// 回溯算法的模版
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

:star: 其实回溯包含了就是两个过程，一个是遍历当前层的可能情况，一个是进入递归进行下一个循环的处理，如图示，上面模版对应的 for 循环就是“横向遍历” 的过程，对应的递归指的就是向下枚举下一个元素的可能的情况。结合图理解上面那段伪代码会更好理解一些。

<img src="https://img-blog.csdnimg.cn/20201123200304469.png" alt="17. 电话号码的字母组合" style="zoom:67%;" />

#### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

```js
var combinationSum = function (candidates, target) {
  const lists = [],
    path = [];
  const backtracking = (candidates, target, sum) => {
    if (sum > target) {
      return;
    } else if (sum === target) {
      lists.push([...path]);
      return;
    }
    for (let i = 0; i < candidates.length; i++) {
      if (candidates[i] < path[path.length - 1]) {
        continue;
      }
      path.push(candidates[i]);
      backtracking(candidates, target, sum + candidates[i]);
      path.pop();
    }
  };

  // 通过排序来排除重复的元素(但显然是不明智的选择)
  candidates.sort((a, b) => a - b);
  backtracking(candidates, target, 0);
  return lists;
};
```

一开始做的时候采用的是先排序然后在递归过程中来进行去重，虽然是通过了但是其实算法的效率并不理想。

:exclamation: 关于什么时候要加入 startIndex 的问题

- 如果是一个集合来求组合的话，就需要 startIndex，例如：[77.组合](https://programmercarl.com/0077.组合.html)，[216.组合总和 III ](https://programmercarl.com/0216.组合总和III.html)。

- 如果是多个集合取组合，各个集合之间相互不影响，那么就不用 startIndex，[17.电话号码的字母组合](https://programmercarl.com/0017.电话号码的字母组合.html)

> 之前没有把握好 startIndex，导致需要进行 sort 去重

```js
var combinationSum = function (candidates, target) {
  const lists = [],
    path = [];
  const backtracking = (candidates, target, sum, startIndex) => {
    if (sum > target) {
      return;
    } else if (sum === target) {
      lists.push([...path]);
      return;
    }
    for (let i = startIndex; i < candidates.length; i++) {
      path.push(candidates[i]);
      backtracking(candidates, target, sum + candidates[i], i);
      path.pop();
    }
  };

  backtracking(candidates, target, 0, 0);
  return lists;
};
```

> 一个优化策略是先去重然后再进行循环内 sum + candidates[i] <= target 的验证，这样可以有效剪枝。

#### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

区别于上面的题目，在于可能出现多个[1, 1, 2]的情况，因为同层可能有多个相同的起点。

```js
var combinationSum2 = function (candidates, target) {
  // 使用 used 数组进行去重
  const lists = [],
    path = [],
    used = Array(candidates.length).fill(0);
  const backtracking = (candidates, target, startIndex, sum) => {
    if (sum > target) {
      return;
    }
    if (sum === target) {
      lists.push([...path]);
      return;
    }

    /* 难点在于如何去除重复数字 */
    /* 最简单的应该就是使用一个变量 t，记录每个节点执行完后值来进行相同起点 */
    for (
      let i = startIndex;
      i < candidates.length && sum + candidates[i] <= target;
      i++
    ) {
      if (i > 0 && candidates[i] === candidates[i - 1] && used[i - 1] === 0) {
        continue;
      }
      used[i] = 1;
      path.push(candidates[i]);
      backtracking(candidates, target, i + 1, sum + candidates[i]);
      path.pop();
      used[i] = 0;
    }
  };

  candidates.sort((a, b) => a - b);
  backtracking(candidates, target, 0, 0);
  return lists;
};
```

<img src="E:\杂七杂八的东西\typeorm 图片存储区\20201123202736384.png" alt="40.组合总和II" style="zoom:50%;" />

:key: 关键在于去除的策略。是保证同一层不能使用存在相同的起点还是说同一趟不能存在相同的元素？

- 同一层指的是 for 循环
- 同一趟指的是递归过程

### 组合切割问题

里面涉及到两个题目，[分割回文串](https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)、[复原 IP 地址](https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)

<img src="E:\杂七杂八的东西\typeorm 图片存储区\20201123203228309.png" alt="131.分割回文串" style="zoom:50%;" />

![93.复原IP地址](E:\杂七杂八的东西\typeorm 图片存储区\20201123203735933.png)

切割组合问题的和上面组合问题不同的地方在于它是以切割位置来进行组合，也就是通过以不同开始串长度往后递归枚举的，所以我们在切割的时候就通过截取 [startindex, i]，然后判断 startindex 是否 >= s.length 来结束递归。

#### [78. 子集](https://leetcode.cn/problems/subsets/)

```js
var subsets = function (nums) {
  /* 子集可以为空 */
  const list = [],
    path = [];
  const backtracking = (nums, startIndex) => {
    /* 不需要进行其他条件 */
    list.push([...path]);
    if (startIndex >= nums.length) {
      return;
    }
    for (let i = startIndex; i < nums.length; i++) {
      path.push(nums[i]);
      backtracking(nums, i + 1);
      path.pop();
    }
  };
  backtracking(nums, 0);
  return list;
};
```

### 子序列问题

#### [491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)

同样是需要去重，但是不能重新进行排序，可以使用 used 数组，利用每次递归重新初始化的效果来进行每一层相同元素的去重

```js
var findSubsequences = function (nums) {
  /* 相同元素也可以被当做递增序列的特殊情况 */
  const lists = [],
    path = [];
  const backtracking = (nums, startIndex) => {
    if (path.length >= 2) {
      lists.push([...path]);
    }
    // 每层的 used 都会重置
    const used = Array(202).fill(0);
    for (let i = startIndex; i < nums.length; i++) {
      if (i > 0 && used[nums[i] + 100] === 1) {
        continue;
      }
      if (path.length && nums[i] < path[path.length - 1]) {
        continue;
      }
      path.push(nums[i]);
      used[nums[i] + 100] = 1;
      backtracking(nums, i + 1);
      path.pop();
    }
  };

  // 题目指的是按照原来的顺序
  // nums.sort((a, b) => a - b)
  backtracking(nums, 0);
  return lists;
};
```

### 排列问题

#### [46. 全排列](https://leetcode.cn/problems/permutations/)

排列问题不再需要使用 startIndex， 每次都从 0 开始进行每一层的遍历，但是每一层的元素和上面层已经选择的元素不能重复，所以需要用 used 数组进行去重。

![46.全排列](https://img-blog.csdnimg.cn/20201209174225145.png)

### 去重问题

![90.子集II2](https://img-blog.csdnimg.cn/2020111316440479.png)

### 数独判断

- 行维度
- 列维度
- 3\*3 小格维度

行和列维度都是可以理解的，但是小格这个维度还是觉得有点难推理。大概的思路是给定一个 [x, y] 的格子，计算该格子是属于哪个 3\*3 小方格，计算的方式：

```js
// 总共有 9 个小方格，从 0-8 依次编号
// 我们得到的是小方格的开始 row 和开始 col
startRow = Math.floor(row / 3) * 3;
startCol = Math.floor(col / 3) * 3;

/*验证一下
假如 x ∈ 0-2 x y ∈ 0-2那么得到的结果就是 0 0 开始
假如 x ∈ 0-2 x y ∈ 3-5那么得到的结果就是 0 3 开始
假如 x ∈ 0-2 x y ∈ 6-8那么得到的结果就是 0 6 开始
假如 x ∈ 3-5 x y ∈ 0-2那么得到的结果就是 3 0 开始
假如 x ∈ 3-5 x y ∈ 3-5那么得到的结果就是 3
... 后面就依次类推了
*/
```

## 十三、专题之贪心算法

![贪心算法大纲](https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png)

关键：局部最优推出全局最优，属于动态规划的特殊类。

- 将问题分解为若干个子问题
- 找出合适的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

对于其中的每一个格子，我们其实不需要明确要跳多少步，其实我们只需要明确当前格子可以覆盖的范围是多少即可，如果最终的覆盖范围包括最终点的话的，那么就认为是可行的，否则就不可行。

```js
var canJump = function (nums) {
  let max = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    max = Math.max(max, i + nums[i]); // 当前能够到达的最远的地方
    if (max <= i) {
      // 不能进入到下一格
      return false;
    }
  }
  // 最右覆盖范围是否能够到达末尾
  return max >= nums.length - 1;
};
```

[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

关键的一句话：如果移动下标达到了当前步的最大移动下标但是还没有到达终点的话，必须 + 1 来继续扩大移动范围。每次到达 currIndex 的时候就判断是否已经到终点了，没有的话就要进行下一跳的操作，因为 nextIndex 记录着下一条能够到达的最远下标，所以可以通过判断 nextIndex 是否大于 nums.length - 1 来判断当前循环是否终止。

```js
var jump = function (nums) {
  if (nums.length === 1) {
    return 0;
  }
  let currNIndex = 0, // 一开始是0步
    nextIndex = 0,
    ans = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    nextIndex = Math.max(nums[i] + i, nextIndex);
    if (i === currNIndex) {
      if (currNIndex == nums.length - 1) {
        break;
      }
      ans++;
      currNIndex = nextIndex;
      if (nextIndex >= nums.length - 1) {
        break;
      }
    }
  }
  return ans;
};
```

### 加油站问题

[134. 加油站](https://leetcode.cn/problems/gas-station/)

基本的思路就是找到一个最优的方案，最优的方案就是说在走的过程中不会出现走不动的情况，假如遇到一个点，发现走到下一个点 gas - cost < 0，那就说明当前这个点绝对不可能是起点，因为你已经在前面有累积的情况下还是走不到，那你自己作为起点就更不可能通过了，所以就进行当前节点的下一个节点是否是开始节点进行判断(当然要重置 gas 为 0)

```js
var canCompleteCircuit = function (gas, cost) {
  let sum = 0,
    index = 0,
    count = 0;
  for (let i = 0; i < gas.length; i++) {
    count += gas[i] - cost[i]; // 到达第 i 个站
    sum += gas[i] - cost[i];
    if (sum < 0) {
      sum = 0;
      index = i + 1;
    }
  }
  if (count < 0) {
    return -1;
  }
  return index === gas.length ? 0 : index;
};
```

### 多维度贪心

[406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

题目比较有意思的是涉及到两个维度的贪心，一个是身高，另外一个是排序人数。代码随想录里面给的思路就是凡是涉及到多维度的判断的话首先确定一个维度然后再考虑其他方面这样就不会顾此失彼。这道题目首先应该根据身高按高到低排序，然后其实对应的排名就是对应数组的索引了(为什么？假设有 7 7 6 5，5 的排序是 2，那么放到数组索引为 2 的地方 7 7 5 6 是正确的)

```js
var reconstructQueue = function (people) {
  people.sort((a, b) => {
    if (a[0] === b[0]) {
      return a[1] - b[1];
    } else {
      return b[0] - a[0];
    }
  });

  const match = [];
  for (let i = 0; i < people.length; i++) {
    match.splice(people[i][1], 0, people[i]);
  }
  return match;
};
```

### 股票贪心问题

[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```js
var maxProfit = function (prices) {
  /* 在尽可能低的情况下买入 & 在高位卖出 */
  /* 只能得到最终利益但不能模拟股票交易的过程 */
  /* 1 3 8 可以在1购买，3卖出，3购买，8卖出 */
  /* 也可以在1购买，8卖出都是一样的结果 */
  let result = 0;
  for (let i = 1; i < prices.length; i++) {
    result += Math.max(prices[i] - prices[i - 1], 0);
  }
  return result;
};
```

[714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

在前一个问题的基础上加了手续费，因此我们就得去控制交易的次数才能保证最大的利润

### 区间贪心

[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

题目的思路其实就是区间的贪心，尽可能找到覆盖面积广一些的。区间贪心难点就在于说右边界其实是需要变化的。

1. 如果 points\[i][0] < points\[i-1][1]：有重叠(右边界需要更新 [1, 6] [3, 4] 此时重叠部分 [3, 4]， 有边界就要更新为 4)
2. 如果 points\[i][0] > points\[i-1][1]: 不存在重叠(右边界更新为 points\[i][1] 即可)

```js
var findMinArrowShots = function (points) {
  points.sort((a, b) => {
    if (a[0] === b[0]) {
      return a[1] - b[1];
    } else {
      return a[0] - b[0];
    }
  });
  let arrows = 1,
    right = points[0][1];
  for (let i = 1; i < points.length; i++) {
    if (points[i][0] > right) {
      arrows++;
      right = points[i][1];
    } else {
      right = Math.min(points[i][1], right);
    }
  }
  return arrows;
};
```

[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

难点：

1. 题目要找的是需要删除的区间数，但是可以换个思路，就是其实需要删除的区间数 = 总区间数 - 不重叠的区间数
2. 排序的基准(是按照有边界排序还是左边界排序会更方便一些)
3. 排序后的处理：找不重叠区间，找到后更新右边边界

```js
var eraseOverlapIntervals = function (intervals) {
  intervals.sort((a, b) => {
    if (a[1] === b[1]) {
      return a[0] - b[0];
    } else {
      return a[1] - b[1];
    }
  });
  let disoverlaps = 1,
    ends = intervals[0][1];
  for (let i = 1; i < intervals.length; i++) {
    let item = intervals[i];
    if (item[0] >= ends) {
      disoverlaps++;
      ends = item[1];
    }
  }
  return intervals.length - disoverlaps;
};
```

[763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

贪心：字符串最远边界的更新。

1. 起点字母：字符串开始的第一个字符
   1. 起点字母就只有一个，直接切开
   2. 起点字母不止一个，那个记录最后一个的下标，并在后续进行更新。当字符串遍历到当前最远边界的时候就可以切断字符串，这时就能保证当前字符串所有的字母不会出现在后面。

```js
var partitionLabels = function (s) {
  const ret = [];
  let index = -1,
    start = 0;
  for (let i = 0; i < s.length; i++) {
    if (i === index) {
      ret.push(s.slice(start, index + 1));
      start = index + 1;
      continue;
    }
    const t = s.lastIndexOf(s.charAt(i)); // 可以使用哈希表进行查找速度的优化
    if (start === t) {
      ret.push(s.charAt(t));
      start++;
      continue;
    }
    index = Math.max(t, index);
  }
  return ret.map((item) => item.length);
};
```

[56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

找重叠区间然后更新覆盖重叠区间的最大区间([1, 6], [4, 8] => [1, 8])

```js
var merge = function (intervals) {
  intervals.sort((a, b) => {
    if (a[0] === b[0]) {
      return a[1] - b[1];
    } else {
      return a[0] - b[0];
    }
  });

  const ret = [];
  let start = intervals[0][0],
    end = intervals[0][1];
  for (let i = 1; i < intervals.length; i++) {
    if (intervals[i][0] <= end) {
      end = Math.max(end, intervals[i][1]);
    } else {
      // 添加的是上一个最大覆盖区间
      ret.push([start, end]);
      start = intervals[i][0];
      end = intervals[i][1];
    }
  }
  ret.push([start, end]); // 因此最后肯定是遗留下最后一个区间没有添加
  return ret;
};
```

### 其他类别

[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

![376.摆动序列1](https://img-blog.csdnimg.cn/20201124174357612.png)

局部最优：当前单调区间的波峰和波底

全局最优：波峰和波底的累加总和

(边界条件的考虑：序列数为 1， 序列数为 2 ……)

```js
var wiggleMaxLength = function (nums) {
  let count = 1, // 默认存在峰值
    perValue = 0,
    currValue = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    currValue = nums[i + 1] - nums[i];
    if (currValue > 0 && perValue <= 0) {
      count++;
      perValue = currValue;
    } else if (currValue < 0 && perValue >= 0) {
      count++;
      perValue = currValue;
    }
  }
  return count;
};
```

[738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

在写的时候思路好乱就是没有一个标准，看了题解以后有了些感悟，就是说对于贪心算法不要总览地去看，先从局部最优想起，局部最优是啥？可以推出啥？不要看着一寸数字就在那硬推。这道题的局部最优是当 numbers[i-1] > nums[i] 时，将 nums[i] 置为 9，然后 numbers[i-1]--。第二个难点就在于怎么把这些局部最优串联起来，设置一个标志位 flag，标识应该从 where 开始将后面的所有数字都变为 9.

```js
var monotoneIncreasingDigits = function (n) {
  const numbers = String(n)
    .split("")
    .map((item) => +item);
  let flag = Infinity; // 记录补 9 初始化位置
  for (let i = numbers.length - 1; i >= 1; i--) {
    if (numbers[i - 1] > numbers[i]) {
      numbers[i] = 9; // 可省略
      numbers[i - 1]--;
      flag = i;
    }
  }
  for (let i = flag; i < numbers.length; i++) {
    numbers[i] = 9;
  }
  return +numbers.join();
};
```

变变场景假设是单调递减的数字求最大值？

```js
var monotoneDecreasingDigits = function (n) {
  const numbers = String(n)
    .split("")
    .map((item) => +item);
  for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] < numbers[i + 1]) {
      numbers[i + 1] = numbers[i];
    }
  }
  n = numbers.join("");
  return +n;
};
```

## 十四、 专题之动态规划

这种类型的题目往往是出现在笔试中，面试一般不会涉及到(但是不会的话很难过笔试 hhh)动态规划区分于贪心算法，最优解是由子问题一步步推导得出来的，而贪心是局部最优推出全局最优，两者性质不一样。

做题的思路：

1. 确定 dp 数组（dp table）以及下标的含义
2. 确定递推公式
3. dp 数组如何初始化
4. 确定遍历顺序
5. 举例推导 dp 数组

[509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

```js
var fib = function (n) {
  if (n === 0) {
    return 0;
  }
  const dp = [0, 1];
  for (let i = 2; i <= n; i++) {
    let tmp = dp[0] + dp[1];
    dp[0] = dp[1];
    dp[1] = tmp;
  }
  return dp[1];
};
```

从这道简单题理清楚动态规划的思路。

1. dp 数组及其下标的定义

​ 对于斐波那契数列来说，dp[i] 代表的是第 i 项的数字

2. 确定递推公式

​ 斐波那契数列的特征就是当前项的前面两项的和，因此 dp[i] = dp[i-1] + dp[i-2]

3. dp 数组如何初始化

​ 题目已经给了 dp[0] = 0, dp[1] = 1，因此初始化就按照题意即可

4.  dp 数组的遍历顺序

        因为 dp[i] = dp[i-1] + dp[i-2]，所以是从前往后遍历

5.  举例枚举 dp 数组

​ dp[0] = 0, dp[1] = 1, dp[2] = 1, dp[3] = 2, dp[4] = 5 ……

​ 可以尝试把 dp 数组 log 出来看下是否与猜测的一致

[746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

这道题目难点在于 dp 数组的定义，dp[i] 代表的是到第 i 个阶梯需要花费的力气。在初始化的时候执行 const dp = [cost[0], cost[1]] ，也就是说其实 dp[i] 的初始就要花费力气了，因此在后续的遍历的时候也要遵循这个规则。

```js
var minCostClimbingStairs = function (cost) {
  const dp = [cost[0], cost[1]];
  for (let i = 2; i < cost.length; i++) {
    dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
  }
  return Math.min(dp[cost.length - 1], dp[cost.length - 2]);
};
```

- 最小回文串

```javascript
function longestPalindromeSubSeq(s) {
  const n = s.length;
  const dp = Array.from(Array(n), () => Array(n).fill(0));

  // 所有对角线的元素置为 1(因为每个字符其实都算作是一个回文串)
  for (let i = 0; i < n; i++) dp[i][i] = 1;
  /*
        dp[i][j] 表示的是[i, j]范围内的回文串的长度
        状态转移：dp[i][j] = i === j ? dp[i+1][j-1]+2 : max(dp[i+1][j], dp[i][j-1])
    */
  for (let i = n - 1; i >= 0; i--) {
    for (let j = i + 1; j < n; j++) {
      if (s.charAt(i) === s.charAt(j)) {
        dp[i][j] = dp[i + 1][j - 1] + 2;
      } else {
        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
      }
    }
  }
  return dp[0][n - 1];
}
```

[62. 不同路径](https://leetcode.cn/problems/unique-paths/)

```js
/**
 * @description leetcode 62. 不同路径
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function (m, n) {
  // dp[i][j] 走到方格 [i][j] 的路径数
  const dp = Array.from(Array(m + 1), () => Array(n + 1).fill(0));
  for (let i = 1; i <= m; i++) {
    dp[i][1] = 1;
  }
  for (let j = 1; j <= n; j++) {
    dp[1][j] = 1;
  }
  console.log(JSON.stringify(dp));
  for (let i = 1; i <= m; i++) {
    if (i === 1) {
      continue;
    }
    for (let j = 1; j <= n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  // console.log(dp)
  return dp[m][n];
};

uniquePaths(3, 7); // 28

// 现在要求的是路径数，那如果现在换个题意要求的是最短到达的方格数
var minPaths = function (m, n) {
  // dp[i][j] 定位为 到达 [i][j] 格子的最小方格数
  const dp = Array.from(Array(m), () => Array(n).fill(0));

  // 递推公式 dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + 1

  // 初始化的过程
  for (let i = 0; i < m; i++) {
    dp[i][0] = i;
  }
  for (let j = 0; j < n; j++) {
    dp[0][j] = j;
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;
    }
  }

  console.log(JSON.stringify(dp));
  return dp[m - 1][n - 1];
};

console.log(minPaths(3, 7));
```

[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

典型的动态规划题目，当前状态由前一个状态推导得到。

```javascript
var uniquePathsWithObstacles = function (obstacleGrid) {
  // m 行数；n 列数
  const m = obstacleGrid.length,
    n = obstacleGrid[0].length;
  const dp = Array.from(Array(m), () => Array(n).fill(0));

  // 关键的初始化不能出错
  for (let i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
  for (let j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      if (obstacleGrid[i][j] === 1) {
        dp[i][j] = 0;
        continue;
      }
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m - 1][n - 1];
};
```

[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

```js
const numTrees = (n) => {
  let dp = new Array(n + 1).fill(0);
  dp[0] = 1;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] += dp[j - 1] * dp[i - j];
    }
  }

  return dp[n];
};
```

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```js
// 自顶向下的备忘录的解法
let meno = [];
var longestCommonSubsequence = function (s1, s2) {
  // 使用动态规划的备忘录方法
  let m = s1.length,
    n = s2.length;
  meno = Array.from(Array(m), () => Array(n).fill(-1));
  return dp(s1, 0, s2, 0);
};

function dp(s1, i, s2, j) {
  if (i === s1.length || j === s2.length) {
    // 如果任意一个的长度为 0
    return 0;
  }

  if (meno[i][j] !== -1) {
    return meno[i][j];
  }

  // 根据s1[i]和s2[j]的情况做选择
  if (s1.charAt(i) === s2.charAt(j)) {
    // 如果相等那么必然在最长子序列中
    meno[i][j] = 1 + dp(s1, i + 1, s2, j + 1);
  } else {
    // 如果不相等
    meno[i][j] = Math.max(dp(s1, i + 1, s2, j), dp(s1, i, s2, j + 1));
  }
  return meno[i][j];
}
```

### [**0-1 背包问题**](https://www.programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20210121%E5%8A%A8%E8%A7%84%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html#%E5%91%A8%E4%BA%8C)

普通解法

```js
function testWeightBagProblem(weight, value, size) {
  // 定义 dp 数组
  const len = weight.length,
    dp = Array(len)
      .fill()
      .map(() => Array(size + 1).fill(0));

  // 初始化
  for (let j = weight[0]; j <= size; j++) {
    dp[0][j] = value[0];
  }

  // weight 数组的长度len 就是物品个数
  for (let i = 1; i < len; i++) {
    // 遍历物品
    for (let j = 0; j <= size; j++) {
      // 遍历背包容量
      if (j < weight[i]) dp[i][j] = dp[i - 1][j];
      else
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
  }

  console.table(dp);

  return dp[len - 1][size];
}

function test() {
  console.log(testWeightBagProblem([1, 3, 4, 5], [15, 20, 30, 55], 6));
}

test();
```

[滚动数组解法](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84)

```js
function testWeightBagProblem(wight, value, size) {
  const len = wight.length,
    dp = Array(size + 1).fill(0);
  for (let i = 1; i <= len; i++) {
    for (let j = size; j >= wight[i - 1]; j--) {
      dp[j] = Math.max(dp[j], value[i - 1] + dp[j - wight[i - 1]]);
    }
  }
  return dp[size];
}

function test() {
  console.log(testWeightBagProblem([1, 3, 4, 5], [15, 20, 30, 55], 6));
}

test();
```

​ [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

经典的 0-1 背包动态规划拓展问题，下面分别使用二维数组和一维数组的方式来解决。其中一位数组的遍历顺序是从尾部开始，为什么呢？因为 0-1 背包问题可能选择的情况只有 0 和 1，不可能存在多个，如果正序遍历的话，前面的物品可能被放置多次导致最后的结果出错。

1. 二维数组 dp 的定义：从下标为[0-i]的物品里任意取，放进容量为 j 的背包，价值总和最大是多少
2. 一维数组 dp 的定义：容量为 j 的背包可以放入的物品的价值总和最大

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function (nums) {
  if (nums.length === 1) {
    return false;
  }
  /* 对应两个子集的元素和肯定是 sum / 2 */

  /* 使用二维数组解决问题 */
  const doubleArray = () => {
    const sum = nums.reduce((a, b) => a + b, 0);
    if (sum % 2 !== 0) {
      return false;
    }
    const dp = Array.from(Array(nums.length), () => Array(sum / 2 + 1).fill(0));
    // 初始化
    for (let i = 0; i <= sum / 2; i++) {
      if (i >= nums[0]) {
        dp[0][i] = nums[0];
      }
    }

    for (let i = 1; i < nums.length; i++) {
      for (let j = 0; j <= sum / 2; j++) {
        if (nums[i] <= j) {
          dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);
        } else {
          dp[i][j] = dp[i - 1][j];
        }
        if (dp[i][j] === sum / 2) return true;
      }
    }
    return false;
  };

  /* 使用一维数组解决问题 */
  const singleArray = () => {
    const sum = nums.reduce((a, b) => a + b, 0);
    if (sum % 2 !== 0) {
      return false;
    }
    const dp = Array(sum / 2 + 1).fill(0);
    // 初始化
    dp[0] = 0;
    for (let i = 0; i < nums.length; i++) {
      for (let j = sum / 2; j >= nums[i]; j--) {
        dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
      }
    }
    return dp[sum / 2] === sum / 2;
  };
  return singleArray();
};
```

[474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

这道题目是两个维度的 0-1 背包问题，也就是说限制条件从原来的背包容量变为了当前的 0 的个数 & 1 的个数。

```js
var findMaxForm = function (strs, m, n) {
  // 选择的问题(0-1背包的动态规划)
  // 两个物品的维度
  // dp[i][j] i个0,j个1的最大子集
  const dp = Array.from(Array(m + 1), () => Array(n + 1).fill(0));
  for (let i = 0; i < strs.length; i++) {
    // 首先选择物品
    let zeronums = 0,
      onenums = 0;
    for (const item of strs[i]) {
      if (item === "0") zeronums++;
      else onenums++;
    }

    // 对容器的情况进行遍历
    for (let p = m; p >= zeronums; p--) {
      for (let q = n; q >= onenums; q--) {
        dp[p][q] = Math.max(dp[p][q], dp[p - zeronums][q - onenums] + 1);
      }
    }
  }
  return dp[m][n];
};
```

总结下：其实 0-1 背包问题还是蛮好理解的，反正记住一个套路就好，确定好初始的值，然后第一层循环是对物品的遍历，第二层，第三层…… 都是对限制条件的遍历。对物品遍历的过程我们可以理解为是对 dp 的更新过程，因此很容易 dp 的递推就变成了 dp[i\][j] = Math.max( dp[i\][j], dp[i-p\][j-q]) 或者是 dp[i] = Math.max(dp[当前的背包容量], dp[当前的背包容量-物品的质量])，就是一个不断更新 dp 的过程。

### 完全背包问题

### 装满背包的方法

关键词：二维数组；一维数组；遍历顺序；初始化

求 dp[5]（凑成 5 的方法数）

- 已经有一个 1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。
- 已经有一个 2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。
- 已经有一个 3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]
- 已经有一个 4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]
- 已经有一个 5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]

那么凑整 dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。

所以求组合类问题的公式，都是类似这种：

```text
dp[j] += dp[j - nums[i]]
```

:key: 注意 dp[0] 初始化的问题，因为当背包容量为 0 的时候其实默认就有一种方法可以装满背包，因此 dp[0] 初始化为 1

[494. 目标和](https://leetcode.cn/problems/target-sum/)

这道题本质是回溯的一个问题，下面代码是使用回溯的方法来解决问题。

```javascript
var findTargetSumWays = function (nums, target) {
  let count = 0;
  const dfs = (index, sum) => {
    if (index == nums.length) {
      if (sum === target) {
        count++;
      }
      return;
    }

    // 枚举 +
    sum += nums[index];
    dfs(index + 1, sum);
    sum -= nums[index];

    // 枚举 -
    sum -= nums[index];
    dfs(index + 1, sum);
    sum += nums[index];
  };

  dfs(0, 0);

  return count;
};
```

那其实也可以用动态规划的思路，但是理解起来感觉比较抽象，不是很好理解。首先它是这样子的，我们可以理解 target 是由加法和 - 减法和构成的，x 代表的是加法和，sum - x 代表的是减法，x - (sum - x) = target => x = (sum + target) / 2，因此这道题目可以变化为在“背包容量”为 x 的情况下，有多少种情况可以填满整个背包.

```javascript
var findTargetSumWays = function (nums, target) {
  // 动态规划算法感觉太抽象了(用到了0-1背包里面的概念)
  const sum = nums.reduce((a, b) => a + b, 0);
  if (Math.abs(target) > sum) {
    return 0;
  }
  if ((target + sum) % 2) {
    // 奇数无法构造
    return 0;
  }
  const halfSum = (target + sum) / 2;

  const dp = Array(halfSum + 1).fill(0);
  dp[0] = 1;
  for (let i = 0; i < nums.length; i++) {
    for (let j = halfSum; j >= nums[i]; j--) {
      // 容量为 j 的情况下，可以构造的种数
      dp[j] += dp[j - nums[i]];
    }
  }
  return dp[halfSum];
};
```

[518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)

```js
var change = function (amount, coins) {
  const dp = Array(amount + 1).fill(0);
  dp[0] = 1; // 注意容量为 0 的时候默认就有一种方法凑出 0
  for (let i = 0; i < coins.length; i++) {
    for (let j = coins[i]; j <= amount; j++) {
      dp[j] += dp[j - coins[i]];
    }
  }
  return dp[amount];
};
```

```js
// 上面是求组合数
// 那如果是求排列数呢？
var change = function (amount, coins) {
  const dp = Array(amount + 1).fill(0);
  dp[0] = 1;
  for (let i = 0; i <= amount; i++) {
    for (let j = 0; j < coins.length; j++) {
      if (i >= coins[j]) {
        dp[i] += dp[i - coins[j]];
      }
    }
  }
  console.log(dp);
};
```

### 打家劫舍问题

[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

```js
var rob = function (nums) {
  //dp[i] 从0-i下标的房间偷能得到的最高金额
  const dp = Array(nums.length).fill(0);
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0], nums[1]);
  for (let i = 2; i < nums.length; i++) {
    // dp[i-2] + nums[i] 表示考虑偷当前家和前前一家
    // dp[i-1] 表示考虑偷前一家
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
  }
  return dp[nums.length - 1];
};
```

[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

题目和上面不一样的地方在于围成一圈，那么就意味着最后一家和第一家是连在一起的，之前考虑的其实是连在一起去判断，但是想了下感觉不好处理，题解给出的是分开两种情况去判断

```js
var rob = function (nums) {
  const preRob = (nums, start, end) => {
    const dp = Array(end - start + 2);
    dp[start] = nums[start];
    dp[start + 1] = Math.max(nums[start], nums[start + 1]);
    for (let i = start + 2; i <= end; i++) {
      dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
    }
    return dp[end];
  };

  // 需要额外考虑两种极端情况
  if (nums.length === 0) {
    return 0;
  }
  if (nums.length === 1) {
    return nums[0];
  }
  const val1 = preRob(nums, 0, nums.length - 2),
    val2 = preRob(nums, 1, nums.length - 1);

  return Math.max(val1, val2);
};
```

[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

涉及到树形 dp 的概念，本质是在树遍历的过程中维护一个 dp 数组（选择 & 不选择的状态），因为其实递归的过程会帮我们记录下 dp，因此实际只需要创建一个 [0, 1] 的数组即可。

```js
// [0, 1] 第一个元素表示不选择当前节点得到的最大值，第二个元素表示选择当前节点得到的最大值
var rob = function (root) {
  const postOrder = (root) => {
    // 树型 dp
    if (root == null) {
      return [0, 0];
    }
    if (root.left == null && root.right == null) {
      return [0, root.val];
    }
    const left = postOrder(root.left);
    const right = postOrder(root.right);
    // val1 考虑根节点，不选择左右子结点 / val2 不考虑根节点，考虑左右子结点
    const val1 = root.val + left[0] + right[0],
      val2 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    return [val2, val1];
  };
  const res = postOrder(root);
  return Math.max(...res);
};
```

### 股票买卖问题

[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

```javascript
function maxProfit(prices = []) {
  // 动态规划的思路
  // dp[0, 1]
  // dp[i][0] 第 i 天持有股票的最大现金
  // dp[i][1] 第 i 天不持有股票的最大现金
  const dp = Array.from(Array(prices.length), () => Array(2).fill(0));
  dp[0][0] = -prices[0];
  dp[0][1] = 0;
  for (let i = 1; i < prices.length; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); // 前一天有没有买股票
    dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
  }
  return dp[prices.length - 1][1]; // 不持有股票的最大现金
}
```

[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```js
function maxProfit(prices = []) {
  // dp[i][0] 第 i 天持有股票
  // dp[i][1] 第 i 天不持有股票
  const dp = Array.from(Array(prices.length), () => Array(2).fill(0));
  dp[0][0] = -prices[0];
  dp[0][1] = 0;
  for (let i = 1; i < prices.length; i++) {
    //(持有)   1.维持昨天的购买状态  2.昨天卖了，今天买了
    dp[i][0] = Math.max(dp[i - 1][0], -prices[i] + dp[i - 1][1]);
    //(不持有) 1.维持昨天的不购买状态 2. 昨天还在的，今天卖掉了
    dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
  }
  return dp[prices.length - 1][1];
}
```

[123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

```js
var maxProfit = function (prices) {
  // 利用状态机去求解
  const dp = Array.from(Array(prices.length), () => Array(5).fill(0));
  dp[0][0] = 0; // 第一天没有任何操作
  dp[0][1] = -prices[0]; // 第一天买入
  dp[0][2] = 0; // 第一天第一次卖出
  dp[0][3] = -prices[0]; // 第一天第二次买入
  dp[0][4] = 0; // 第一天第二次卖出

  for (let i = 1; i < prices.length; i++) {
    // 要么就是维持昨天的状态，要么就是选择在当前阶段触发
    dp[i][0] = dp[i - 1][0];
    dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
    dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2]);
    dp[i][3] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][3]);
    dp[i][4] = Math.max(dp[i - 1][3] + prices[i], dp[i - 1][4]);
  }
  return dp[prices.length - 1][4];
};
```

[188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

```js
function maxProfit(k, prices = []) {
  // k 次交易其实就是在 III 2 次的基础上将 2 抽取成一个变量
  const dp = Array.from(Array(prices.length), () => Array(2 * k + 1).fill(0));
  for (let i = 0; i < dp[0].length; i++) {
    // 初始化
    if (i % 2 === 0) {
      dp[0][i] = 0;
    } // 收益为 0
    else {
      dp[0][i] = -prices[0];
    } // 支出为 -prices[0]
  }

  for (let i = 1; i < prices.length; i++) {
    for (let j = 0; j < dp[i].length; j++) {
      // j 表示状态
      if (j === 0) {
        dp[i][j] = dp[i - 1][j];
      } else {
        if (j % 2 === 0) {
          // 卖出
          dp[i][j] = Math.max(dp[i - 1][j - 1] + prices[i], dp[i - 1][j]);
        } else {
          // 买入
          dp[i][j] = Math.max(dp[i - 1][j - 1] - prices[i], dp[i - 1][j]);
        }
      }
    }
  }
  return dp[prices.length - 1][2 * k];
}
```

### 子序列问题

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

子序列：不连续的子集

```js
var lengthOfLIS = function (nums) {
  // 首先明白子序列的概念（可以不连续）
  let max = -1;
  const dp = Array(nums.length).fill(1);
  for (let i = 1; i < nums.length; i++) {
    let j;
    for (j = i - 1; j >= 0; j--) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[j] + 1, dp[i]);
      }
    }
    max = Math.max(max, dp[i]);
  }
  return Math.max(dp[nums.length - 1], max);
};

// 如果想记录里面的路径的话
var lengthOfLIS = function (nums) {
  let max = -1,
    index = 0; // 保存索引
  const dp = Array(nums.length).fill(1);
  const chars = [[nums[0]]]; // 保存路径
  for (let i = 1; i < nums.length; i++) {
    chars[i] = [];
    for (let j = i - 1; j >= 0; j--) {
      // 当然这里的路径要想覆盖全的话得用索引表去存
      // 当前只是默认取第一个符合条件的，因此 dp[i] === dp[j] + 1 的情况就被舍弃掉了
      if (nums[i] > nums[j]) {
        if (dp[i] < dp[j] + 1) {
          chars[i] = [...chars[j]];
          dp[i] = dp[j] + 1;
        }
      }
    }
    chars[i].push(nums[i]);
    if (max < dp[i]) {
      max = dp[i];
      index = i;
    }
  }
  console.log(chars[index]);
  return Math.max(dp[nums.length - 1], max);
};
```

[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

区别于子序列，是连续的子集

```js
var findLengthOfLCIS = function (nums) {
  const dp = Array(nums.length).fill(1);
  let max = dp[0];
  for (let i = 1; i < nums.length; i++) {
    dp[i] = nums[i] > nums[i - 1] ? dp[i - 1] + 1 : 1;
    max = Math.max(dp[i], max);
  }
  return max;
};
```

[718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

```js
var findLength = function (nums1, nums2) {
  // 注意是子数组表示连续的意思
  const dp = Array.from(Array(nums1.length), () => Array(nums2.length).fill(0));
  let max = 0;
  for (let i = 0; i < nums1.length; i++) {
    for (let j = 0; j < nums2.length; j++) {
      // dp[i][j]，以nums[i]&nums[j]结束的子数组的最长重复子数组数
      dp[i][j] =
        nums1[i] === nums2[j] ? (i < 1 || j < 1 ? 1 : dp[i - 1][j - 1] + 1) : 0;
      max = Math.max(dp[i][j], max);
    }
  }
  return max;
};
```

[1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

```js
var longestCommonSubsequence = function (text1, text2) {
  // 子序列的定义要清楚
  const dp = Array.from(Array(text1.length + 1), () =>
    Array(text2.length + 1).fill(0)
  );
  for (let i = 1; i <= text1.length; i++) {
    for (let j = 1; j <= text2.length; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }
  return dp[text1.length][text2.length];
};
```

[1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

:smile: 其实代码和上面的最长公共子序列的长度是一样的，因为不能交叉意味着当前不匹配的话

要么就 dp[i-1\][j]，要么就 dp[i\][j-1]

```js
var maxUncrossedLines = function (nums1, nums2) {
  const dp = Array.from(Array(nums1.length + 1), () =>
    Array(nums2.length + 1).fill(0)
  );
  for (let i = 1; i <= nums1.length; i++) {
    for (let j = 1; j <= nums2.length; j++) {
      if (nums1[i - 1] === nums2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }
  return dp[nums1.length][nums2.length];
};
```

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```js
var maxSubArray = function (nums) {
  const dp = Array(nums.length).fill(0);
  // 初始化的问题要注意
  let max = nums[0];
  dp[0] = nums[0];
  for (let i = 1; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
    max = Math.max(max, dp[i]);
  }
  return max;
};
```

:key: 这么一看其实子序问题的关键就在于相等和不想等的比较

- nums[i] === nums[j]
- nums[i] !== nums[j]

分别对这两种情况做处理

### 编辑距离问题

[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

```js
// dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。
var isSubsequence = function (s, t) {
  // 注意是子序列
  const dp = Array.from(Array(s.length + 1), () => Array(t.length + 1).fill(0));
  for (let i = 1; i <= s.length; i++) {
    for (let j = 1; j <= t.length; j++) {
      if (s[i - 1] === t[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = dp[i][j - 1]; //*
      }
    }
  }
  return dp[s.length][t.length] === s.length;
};
```

[115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

```js
// 其实把表列出来递推关系就出来了
var numDistinct = function (s, t) {
  // 计算出现的个数
  // 以下标 i-1 结束的字符串在以下标 j-1结束的字符串中出现的次数
  const dp = Array.from(Array(t.length + 1), () => Array(s.length + 1).fill(0));
  // 注意初始化的问题
  for (let i = 0; i <= s.length; i++) {
    dp[0][i] = 1;
  }
  for (let i = 1; i <= t.length; i++) {
    for (let j = 1; j <= s.length; j++) {
      if (t[i - 1] === s[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];
      } else {
        dp[i][j] = dp[i][j - 1];
      }
    }
  }
  return dp[t.length][s.length];
};
```

[583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

```js
var minDistance = function (word1, word2) {
  // 当前操作只可以删除（不可新增）
  // 本质上是求最大公共子序列，最后长的字符串长度 - 最大公共子序列长度就是操作数了
  const dp = Array.from(Array(word1.length + 1), () =>
    Array(word2.length + 1).fill(0)
  );
  for (let i = 1; i <= word1.length; i++) {
    for (let j = 1; j <= word2.length; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }
  return word1.length + word2.length - 2 * dp[word1.length][word2.length];
};
```

[72. 编辑距离](https://leetcode.cn/problems/edit-distance/description/)

基于动态规划的思维；dp[i\][j] 的定义为长度为 i 的 word1，长度为 j 的 word2 的最小转换次数

- word1[i] === word2[j] 可以得到 dp[i\][j] = dp[i-1\][j-1]

- word1[i] !== word2[j]

  - 删除 word1 的一个字符：dp[i-1\][j]
  - 删除 word2 的一个字符：dp[i\][j-1]
  - 替换 word1 的一个字符使得与 word2 相等，那么这个操作就类似在在 dp[i-1\][j-1] 的基础上加上一个替换

  三种情况的编辑距离取最小值

![72.编辑距离](https://img-blog.csdnimg.cn/20210114162113131.jpg)

```javascript
var minDistance = function (word1, word2) {
  // bibi 秋招的笔试题目
  // 插入/删除/替换
  const dp = Array.from(Array(word1.length + 1), () =>
    Array(word2.length + 1).fill(0)
  );
  for (let i = 0; i <= word1.length; i++) {
    dp[i][0] = i;
  }
  for (let i = 0; i <= word2.length; i++) {
    dp[0][i] = i;
  }
  for (let i = 1; i <= word1.length; i++) {
    for (let j = 1; j <= word2.length; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i][j - 1] + 1,
          dp[i - 1][j] + 1,
          dp[i - 1][j - 1] + 1
        );
      }
    }
  }
  return dp[word1.length][word2.length];
};
```

### 综合题目

[62. 不同路径](https://leetcode.cn/problems/unique-paths/)

```js
var uniquePaths = function (m, n) {
  // dp[i][j] 走到方格 [i][j] 的路径数
  const dp = Array.from(Array(m + 1), () => Array(n + 1).fill(0));
  for (let i = 1; i <= m; i++) {
    dp[i][1] = 1;
  }
  for (let j = 1; j <= n; j++) {
    dp[1][j] = 1;
  }
  for (let i = 1; i <= m; i++) {
    if (i === 1) {
      continue;
    }
    for (let j = 1; j <= n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m][n];
};
```

[647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

```js
var countSubstrings = function (s) {
  // 中心扩散法计算回文子串的数量
  let sum = 0;
  const isHuiWen = (s, i, j, n) => {
    while (i >= 0 && j < n) {
      if (s[i] === s[j]) {
        sum++;
      } else {
        break;
      }
      i--;
      j++;
    }
  };
  for (let i = 0; i < s.length; i++) {
    isHuiWen(s, i, i, s.length);
    isHuiWen(s, i, i + 1, s.length);
  }
  return sum;
};

var countSubstrings = function (s) {
  // dp[i][j] 以i开始j结束的字符串是否是回文串
  const dp = Array.from(Array(s.length), () => Array(s.length).fill(0));
  let sum = 0;
  for (let i = s.length - 1; i >= 0; i--) {
    for (let j = i; j < s.length; j++) {
      if (s[i] === s[j] && j - i <= 1) {
        // 包含了 j === i 的情况
        dp[i][j] = 1;
        sum++;
      } else if (s[i] === s[j] && dp[i + 1][j - 1]) {
        dp[i][j] = 1;
        sum++;
      }
    }
  }
  return sum;
};
```

[516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

```js
// 相等 -> [i+1, j-1] + 2
// 不相等 -> max([i, j-1], [i+1, j])
var longestPalindromeSubseq = function (s) {
  const dp = Array.from(Array(s.length), () => Array(s.length).fill(0));
  for (let i = 0; i < s.length; i++) {
    dp[i][i] = 1;
  }
  for (let i = s.length - 1; i >= 0; i--) {
    for (let j = i + 1; j < s.length; j++) {
      if (s[i] === s[j]) {
        dp[i][j] = dp[i + 1][j - 1] + 2;
      } else {
        dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
      }
    }
  }
  return dp[0][s.length - 1];
};
```

### 总结

1. 动态规划的理论基础要清晰
   1. dp 的定义要清晰
   2. dp 的初始化要清晰
   3. dp 推导方程要清晰
   4. dp 遍历顺序要清晰
   5. dp 验证过程要清晰

基本上按照这 五个步骤来的话其实解题就起码是有思路的。

2. 题目类型

   [^*标识]: - 表示题目可能还存在一些理解性的问题

   1. 简单推导

      - 这种类型的题目一般是一个一维数组可以解决，一般都是可以比较直观地看到递推关系存在的

      - [ ] 斐波那契数列
      - [ ] 走楼梯
      - [ ] 不同路径
      - [ ] 不同路径 II
      - [ ] \*整数拆分
      - [ ] \*不同的二叉搜索树

   2. 背包问题

   - 解决背包问题的关键是区分选和不选的状态

     - 选 - 背包容量减少
     - 不选 - 可选择的物品减少

   - 0-1 背包问题：有且只能选择一次
     - 二维 dp
     - 一维 dp
       - 遍历顺序外层物品，内层背包容量
       - 遍历背包容量需要从大到小保证不会有重复选择的情况
         - 例子：背包容量无限，物品只有一个且重量和价值都是 1
       - 遍历顺序是否可变？(不可变，背包容量必须倒序，那么调换的话每次就只会放一个物品)
       - 组合问题 dp[j] += dp[j-nums[i]]
     - 题目
       - [ ] 分割等和子集
       - [ ] \*目标和
       - [ ] \*一和零
   - 完全背包问题：对于相同的物品可以选择若干次
     - 二维 dp
     - 一维 dp (遍历顺序需要注意-从前往后)
   - \*多背包问题：当前背包不唯一

# 拓展算法

## 建立小根堆

```js
// 迭代建立方法
function minHeapifyIteration(arr, x, len) {
  let minest = x,
    first = true,
    current;

  while (first || current !== arr[minest]) {
    current = arr[minest];
    let leftIndex = 2 * minest + 1,
      rightIndex = 2 * minest + 2;
    first = false;
    if (arr[leftIndex] < arr[minest]) {
      minest = leftIndex;
    }
    if (arr[rightIndex] < arr[minest]) {
      minest = rightIndex;
    }

    if (arr[minest] !== current) {
      let t = arr[x];
      arr[x] = arr[minest];
      arr[minest] = t;
    }
    console.log(current);
  }
}
```

<img src="E:\杂七杂八的东西\typeorm 图片存储区\image-20220917094216577.png" style="display: block; margin: auto;"/>

```js
// 递归解法
function minHeapify(arr, x, len) {
  let leftIndex = 2 * x + 1,
    rightIndex = 2 * x + 2,
    minest = x;
  if (arr[leftIndex] < arr[minest]) {
    minest = leftIndex;
  }
  if (arr[rightIndex] < arr[minest]) {
    minest = rightIndex;
  }

  if (arr[minest] !== arr[x]) {
    let t = arr[x];
    arr[x] = arr[minest];
    arr[minest] = t;
    minHeapify(arr, minest, len); //? 注意点2：记住交换以后要重建堆，重建的节点是 minest 下标的节点
  }
}
```

## 优先队列

```js
/**
 * 每次出队的是最小元素的 min-priority-queue
 */

class MinPriorityQueue {
  // compare 函数是自定义
  constructor(compare = (a = [], b = []) => a[0] - b[0] < 0) {
    this.compare = compare;
    this.data = [];
    this.size = 0;
  }
  isEmpty() {
    return this.data.length === 0;
  }

  peek() {
    return this.data[0];
  }

  poll() {
    this._swap(0, --this.size);
    this._shiftdown(0);
    this.data.pop();
  }
  _shiftdown(index) {
    let left = 2 * index + 1,
      right = 2 * index + 2;
    let minest = index,
      first = true,
      isSwap;
    while (first || minest !== index) {
      isSwap = false;
      first = false;
      if (
        left < this.size &&
        this.compare(this.data[left], this.data[minest])
      ) {
        minest = left;
        isSwap = true;
      }
      if (
        right < this.size &&
        this.compare(this.data[right], this.data[minest])
      ) {
        minest = right;
        isSwap = true;
      }
      if (!isSwap) {
        break;
      }
      if (minest !== index) {
        this._swap(minest, index);
      }
    }
  }

  offer(val) {
    this.data.push(val);
    this._shiftup(this.size++);
  }
  _parent(i) {
    // 这里的设置不能变
    return (i - 1) >> 1;
  }
  _shiftup(index) {
    let parentIdx;
    while (
      (parentIdx = this._parent(index)) >= 0 &&
      this.compare(this.data[index], this.data[parentIdx])
    ) {
      this._swap(parentIdx, index);
      index = parentIdx;
    }
  }

  _swap(a, b) {
    [this.data[a], this.data[b]] = [this.data[b], this.data[a]];
  }
}
```

```js
/**
 * 每次出队的是最大元素 max-priority-queue
 */

class MaxPriorityQueue {
  constructor(compare = (a, b) => a > b) {
    this.compare = compare;
    this.data = [];
    this.size = 0;
  }

  peek() {
    return this.data[0]; // 返回值最大值
  }

  poll() {
    this._swap(0, --this.size);
    this.data.pop();
    // 重新构造堆
    this._shiftdown(0);
  }

  offer(val) {
    this.data.push(val);
    this._shiftup(this.size++); // 引用到下标内部就不用 -1 处理了
  }

  _shiftdown(index) {
    let first = false,
      largest = index,
      isSwap;
    let left = 2 * index + 1,
      right = 2 * index + 2;
    while (first || largest !== index) {
      isSwap = false;
      if (left < this.size && this.data[left] > this.data[largest]) {
        largest = left;
        isSwap = true;
      }
      if (right < this.size && this.data[right] > this.data[largest]) {
        largest = right;
        isSwap = true;
      }
      if (!isSwap) {
        break;
      }
      if (largest !== index) {
        this._swap(largest, index);
      }
    }
  }

  _parent(index) {
    return (index - 1) >> 1;
  }

  _shiftup(index) {
    // 比较 current 和 parent 是否 存在值上的冲突
    let parentIdx;
    while (
      (parentIdx = this._parent(index)) >= 0 &&
      this.data[parentIdx] < this.data[index]
    ) {
      this._swap(parentIdx, index);
      index = parentIdx;
    }
  }

  _swap(a, b) {
    [this.data[a], this.data[b]] = [this.data[b], this.data[a]];
  }
}
```

[1705. 吃苹果的最大数目](https://leetcode.cn/problems/maximum-number-of-eaten-apples/)

```js
class _PriorityQueue {
  constructor(compare = (a = [], b = []) => a[0] - b[0] < 0) {
    this.compare = compare;
    this.data = [];
    this.size = 0;
  }
  isEmpty() {
    return this.data.length === 0;
  }

  peek() {
    return this.data[0];
  }

  poll() {
    this._swap(0, --this.size);
    this._shiftdown(0);
    this.data.pop();
  }
  _shiftdown(index) {
    let left = 2 * index + 1,
      right = 2 * index + 2;
    let minest = index,
      first = true,
      isSwap;
    while (first || minest !== index) {
      isSwap = false;
      first = false;
      if (
        left < this.size &&
        this.compare(this.data[left], this.data[minest])
      ) {
        minest = left;
        isSwap = true;
      }
      if (
        right < this.size &&
        this.compare(this.data[right], this.data[minest])
      ) {
        minest = right;
        isSwap = true;
      }
      if (!isSwap) {
        break;
      }
      if (minest !== index) {
        this._swap(minest, index);
      }
    }
  }

  offer(val) {
    this.data.push(val);
    this._shiftup(this.size++);
  }
  _parent(i) {
    return (i - 1) >> 1;
  }
  _shiftup(index) {
    let parentIdx;
    while (
      (parentIdx = this._parent(index)) >= 0 &&
      this.compare(this.data[index], this.data[parentIdx])
    ) {
      this._swap(parentIdx, index);
      index = parentIdx;
    }
  }

  _swap(a, b) {
    [this.data[a], this.data[b]] = [this.data[b], this.data[a]];
  }
}

function eatenApples(apples = [], days) {
  const q = new _PriorityQueue();
  // 先吃最快腐烂的苹果(过期时间最早)
  let ans = 0,
    d = 0;
  while (d < apples.length || !q.isEmpty()) {
    if (d < apples.length && apples[d] > 0) {
      q.offer([d + days[d], apples[d]]); // [过期日期，苹果数量]
    }
    while (!q.isEmpty() && (q.peek()[0] <= d || q.peek()[1] === 0)) {
      q.poll();
    }
    // 吃苹果
    if (!q.isEmpty()) {
      ++ans;
      q.peek()[1]--;
    }
    ++d;
  }
  return ans;
}

console.log(eatenApples([1, 2, 3, 5, 2], [3, 2, 1, 4, 2]));
```

# 综合题目

[2170. 使数组变成交替数组的最少操作数](https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/)

```js
const minimumOperations = function (nums) {
  if (nums.length === 1) {
    return 0;
  }
  // 该函数可以获取奇数|偶数下标出现的最多重复字符或者数字
  // 同时可以获取次最多重复字符或者数字
  // @return [firstMax, firstMaxNums, secondMax, secondMaxNums]
  const getListMap = (nums = [], start) => {
    const map = new Map();
    for (let i = start; i < nums.length; i += 2) {
      map.set(nums[i], map.get(nums[i]) + 1 || 1);
    }
    let fmax,
      fmaxNums = -1,
      smax,
      smaxNums = fmaxNums - 1;
    for (const key of map.keys()) {
      if (map.get(key) > fmaxNums) {
        smax = fmax;
        smaxNums = map.get(fmax) || 0;
        fmax = key;
        fmaxNums = map.get(key);
      } else if (map.get(key) > smaxNums) {
        smax = key;
        smaxNums = map.get(key);
      }
    }
    return [fmax, fmaxNums, smax, smaxNums];
  };
  const oddMap = getListMap(nums, 0),
    evenMap = getListMap(nums, 1);
  if (oddMap[0] !== evenMap[0]) {
    return nums.length - oddMap[1] - evenMap[1];
  } else {
    return (
      nums.length - Math.max(oddMap[1] + evenMap[3], oddMap[3] + evenMap[1])
    );
  }
};
```
